<!-- TABLE MATIERES -->
<aside>
    <nav id="table_matiere">
        <a href="#general">Généralités</a>
        <a href="#hello">Hello world</a>
        <a href="#variable">Les variables</a>
        <a href="#operation">Principales opérations</a>
        <a href="#tableau">Les tableaux</a>
        <a href="#caractere">les chaînes de caractères</a>
        <a href="#saisie">Saisie utilisateur</a>
        <a href="#condition">Branchement conditionnel</a>
        <a href="#boucle">Les boucles</a>
        <a href="#fonction">Les fonctions</a>
        <a href="#pointeur">Les pointeurs</a>
        <a href="#math">Package math.h</a>
    </nav>
</aside>

<!-- GRAND CONTENU -->
<section id="grandContenu">

<!-- BANDEAU -->
  <h2>DEVELOPMENT TOOLS</h2>

    <div id="bandeau_sousTitre">
      <p>S. Robin (mis à jour le 01 Mar. 2021)</p>
    </div>

  <div id="bandeau_contenu">
    <p>L'essentiel du savoir-faire</p>
  </div>

  <div id="bandeau_controle">
  </div>

  <!-- CONTENU -->
  <section id="contenu">
    


  <!-- ===== GENERALITES ===== -->

  <h3 id="general"> Généralités </h3>

    <p>Les fichiers C ont pour extension <em>.c</em></p>
    
    <p>Toutes les instructions se terminent par <strong>;</strong></p>

    <p>En C, chaque fonction renvoie une fois terminé une valeur. En pratique 0 signifie que tout s'est bien passé.</p>

    <p> <strong>\n</strong> s'emploie pour un retour à la ligne.</p>
    <p> <strong>\t</strong> s'emploie pour une tabulation.</p>

    <p>Les commentaires sur une ligne s'expriment grâce aux symboles <strong>//</strong>. En revanche les commentaires sur plusieurs lignes figurent entre les symboles <strong>/*</strong> et <strong>*/</strong>.</p>
    
    <p>Avant d'être compilés, les fichiers soures S sont traités par un préprocesseur qui résoud certaines directives comme l'inclusion de fichier. Les directives de préprocesseur commencent toujours par un # et sont écrites en début de code.</p>

    <p>L'installation de librairies se fait à l'aide de l'instruction <strong>#include &ltnomLibrairie&gt</strong>.</p>

    <h4>Lancer une compilation avec Makefile</h4>
    
    <p>Une fois le fichier Makefile créé, il faut ouvrir le Terminal et se rendre dans le dossier du projet</p>
    <pre><code class="language-svg">cd Documents/monProjet</code></pre>
    
    <p>puis exécuter le Makefile avec l'instruction</p>
    <pre><code class="language-svg">make</code></pre>
    
    <p>Les fichiers fichiers.c se construisent alors en suivant les directives du Makefile. Pour ouvrir directement un fichier, il faut forcer le compilateur à rester dans le dossier local</p>
    <pre><code class="language-svg">./monFichier</code></pre>
    


  <!-- ===== HELLO WORLD ===== -->

  <h3 id="hello">Hello world</h3>

  <p>Commençons par le traditionnel "Hello world".</p>
  <pre><code class="language-python">#include &ltstdio.h&gt
#include &ltstdlib.h&gt

int main(int argc, char* argv[]){
  printf("Hello world");
  return 0;
}</code></pre>
    

    
<!--- ===== LES VARIABLES ===== -->
    
<h3 id="variable">Les variables</h3>
    
<p>C n'est pas un langage dynamique. Il est nécessaire que définir le type de variables avant leur utilisation. Les différents types de variables en C sont les suivants :</p> 
<p>C est un langage faiblement typé, et ne dispose que de 4 types de variables.</p>

  <table>
    <tr><th>Types</th><th>Mots-clés</th></tr>
    <tr><td>entier court</td><td>char</td></tr>
    <tr><td>entier</td><td>int</td></tr>
    <tr><td>entier long</td><td>long</td></tr>
    <tr><td>nombre décimal</td><td>float</td></tr>
    <tr><td>nombre décimal long</td><td>double</td></tr>
    <tr><td>entier court positif</td><td>unsigned char</td></tr>
    <tr><td>entier positif</td><td>unsigned int</td></tr>
    <tr><td>entier long positif</td><td>unsigned long</td></tr>
  </table>

<p>Attention, bien que le type <strong>char</strong> soit utilisé pour représenter des caractères, il représente quand même initialement en C des nombres compris entre -128 et 127.</p>
<p>Attention, les <strong>unsigned char</strong>, <strong>unsigned int</strong>, ... sont en fait des nombres positifs. La plage mémoire qu'ils occupent a donc été déplacée vers la droite. Ainsi, les nombres de type <strong>unsigned char</strong> sont compris entre 0 et 255. Tous ces différents types de nombres ont été créés pour économiser de la mémoire lors de leur déclaration.</p>

<p>Au moment de la déclaration d'une variable, C réserve un emplacement en mémoire, mais la valeur attribuée initialement à la variable correspond à la dernière valeur prise par cet emplacement de mémoire. Il est donc important de déclarer et d'initialiser en même temps pour éviter des erreurs, en attribuant par exemple la valeur 0 à la variable.</p>

<h4>Particularités de C</h4>

<p>En C il n'existe pas de type booleen. On fait donc prendre les valeurs 0 et 1 à une variable qui va jouer le rôle d'un booléen. Il n'existe pas non plus de type chaîne de caractères. En revanche, le type char qui est un type particulier de nombres compris entre -128 et 127, permet en fait de représenter des caractères. La correspondance entre les nombres et les caractères est assurée par la table ASCII.</p>

<h4>Conversion implicite et cast d'un type</h4>

<p>Dans une expression contenant des éléments de plusieurs types, le type du résultat respecte la règle suivante : le type le plus faible est converti implicitement dans le type le plus fort. Par exemple, un char avec un int produit un int, un int avec un float produit un float. Si on veut convertir de façon explicite une variable dans un autre type (cast), on utilise la forme suivante :</p>
<pre><code class="language-python">int x;
float y = (float)x;</code></pre>

<h4>Affichage d'une variable</h4>
    
<pre><code class="language-python">printf("Antoine a %d ans et %d voitures", age, nbreVoitures);</code></pre>


<table>
    <tr><th>Types</th><th>Mots-clés</th></tr>
    <tr><td>int</td><td>%d</td></tr>
    <tr><td>long</td><td>%ld</td></tr>
    <tr><td>float</td><td>%f</td></tr>
    <tr><td>pointeur</td><td>%p</td></tr>
    <tr><td>char</td><td>%d pour afficher le nombre, %c pour afficher le caractère</td></tr>
    <tr><td>chaîne de caractères</td><td>%s</td></tr>
    <tr><td>float en notation scientifique</td><td>%e</td></tr>
</table>

<h4>Les constantes</h4>

<p>On déclare une constante en C avec l'instruction :</p>
    <pre><code class="language-python">const int MON_NOMBRE = 5;</code></pre>

<h4>Taille des données</h4>

<p>En C, un octet est représenté par un char. L'instruction <strong>sizeof</strong> permet de connaître la taille en octets d'une donnée. La taille d'un char vaut donc 1.</p>


<!-- ===== LES PRINCIPALES OPERATIONS ===== -->

<h3 id="operation"> Les principales opérations </h3>

  <table>
    <tr><th>Opérations</th><th>Symboles</th></tr>
    <tr><td>addition</td><td>+</td></tr>
    <tr><td>soustraction</td><td>-</td></tr>
    <tr><td>multiplication</td><td>*</td></tr>
    <tr><td>division pour des nombres décimaux</td><td>/</td></tr>
    <tr><td>partie entière d'une division</td><td>/</td></tr>
    <tr><td>modulo</td><td>%</td></tr>
    <tr><td>concaténation</td><td>+</td></tr>
    <tr><td>affectation</td><td>=</td></tr>
    <tr><td>égalité</td><td>==</td></tr>
    <tr><td>incrémentation</td><td>++</td></tr>
    <tr><td>décrémentation</td><td>--</td></tr>
    <tr><td>ET logique</td><td>&&</td></tr>
    <tr><td>OU logique</td><td> || </td></tr>
    <tr><td>NON logique</td><td>!</td></tr>
  </table>

<h4>Particularité de C</h4>

<p>En C, le signe division <strong>/</strong> n'a pas le même sens selon que les termes de calcul sont des entiers ou des décimaux.</p> 
<table>
    <tr><th>Type</th><th>Calcul</th><th>Résultat</th></tr>
    <tr><td><pre>int a = 5;
int b = 2;</pre></td><td><pre>int resultat = a/b</pre></td><td>2</td></tr>
    <tr><td><pre>int a = 5;
int b = 2;</pre></td><td><pre>float resultat = a/b</pre></td><td>2.0</td></tr>
    <tr><td><pre>float a = 5.0;
float b = 2.0;</pre></td><td><pre>float resultat = a/b</pre></td><td>2.5</td></tr>
</table>

<h4>Les opérateurs de comparaison</h4>

  <table>
    <tr><th>Signification</th><th>Opérateurs</th></tr>
    <tr><td>égalité</td><td>==</td></tr>
    <tr><td>égalité (valeur et type)</td><td>===</td></tr>
    <tr><td>différent</td><td>!=</td></tr>
    <tr><td>inférieur</td><td><</td></tr>
    <tr><td>inférieur ou égal</td><td><=</td></tr>
    <tr><td>supérieur</td><td>></td></tr>
    <tr><td>supérieur ou égal</td><td>>=</td></tr>
  </table>



<!-- ===== LES TABLEAUX ===== -->

<h3 id="tableau">Les tableaux</h3>

<p>Les tableaux en C sont des objets contenant des variables de même type, et disposant d'une taille fixée.</p>
<p>Notons que les adresses des variables d'un tableau sont contigues.</p>
<p>Pour définir un tableau de 5 <em>int</em> :</p>
    <pre><code class="language-python">int tableau[5];</code></pre>

<p>Pour initialiser un tableau lorsqu'on connaît les valeurs à l'avance :</p>
    <pre><code class="language-python">int tableau[5] = {0, 4, 3, 5, 2};</code></pre>

<p>Il est également possible de laisser le compilateur déterminer la taille du tableau lorsqu'on lui donne les valeurs à l'avance :</p>
    <pre><code class="language-python">int tableau[] = {0, 4, 3, 5, 2};</code></pre>

<p>Comme dans tous les langages, le premier indice d'un tableau est 0.</p>
<p>Par ailleurs, le code suivant renvoie l'adresse de la première case du tableau :</p>
<pre><code class="language-python">int tab[5];
print("%d", tab);</code></pre>

<p>Pour parcourir un tableau :</p>
<pre><code class="language-python">for(int i=0; i<5; i++){
    printf("%d \n", tableau[i];
}</code></pre>

<h4>Propriétés d'un tableau</h4>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>sizeof tab / sizeof tab[0]</pre></td></tr>
    <tr><td>élément d'indice i</td><td><pre>tab[i]</pre></td></tr>
    <tr><td>dernier élément d'une liste</td><td><pre>tab[-1]</pre></td></tr>
    <tr><td>modifier l'élément d'indice i</td><td><pre>tab[i] = nouvelleValeur</pre></td></tr>
    <tr><td>indice d'un élément</td><td><pre>tab.index(element)</pre></td></tr>
  </table>

<h4>Une initialisation particulière à C</h4>

    <pre><code class="language-python">int tableau[5] = {1};</code></pre>
<p>Cette instruction va en fait affecter la valeur 1 au 1er élément du tableau, puis la valeur 0 aux quatre autres.</p>



<!-- ===== MANIPULER DES CHAINES DE CARACTERES ===== -->

<h3 id="caractere">Manipuler des chaînes de caractères</h3>

<h4>Les caractères</h4>

<p>En C un caractère est en fait un nombre stocké tel quel dans la mémoire et affiché sous forme de caractère grâce à la table ASCII, si on le spécifie en utilisant l'attribut <em>%c</em>.</p>

<pre><code class="language-python">char lettre = 'a';
printf("%d", lettre);</code></pre>

<p>affiche 97. En revanche, le code :</p>

<pre><code class="language-python">char lettre = 'a';
printf("%c", lettre);</code></pre>

<p>affiche bien la lettre <em>a</em>.</p>
<p>Notons que les caractères sont obligatoirement entourés de <strong>'</strong> alors que les chaînes de caractères sont entourées de <strong>"</strong>.</p>

<h4>Les chaînes de caractères</h4>

<p>En C, une chaîne de caractères est un tableau de caractères de type char dont le dernier élément est \0. Il s'agit en fait d'un caractère de contrôle non affichable qui permet d'indiquer la fin de la chaîne. Ainsi une chaîne composée de n éléments sera en fait un tableau de n+1 éléments. La taille d'une chaîne de caractères est immuable une fois initialisée. On peut toutefois n'utiliser que partiellement l'espace alloué en insérant le caractère de fin de chaîne \0 à un emplacement avant la fin du tableau.</p>
<p>La bibliothèque <em>string.h</em> offre une multitude de fonctions dédiées aux chaînes.</p>
    <pre><code class="language-python">#include &ltstring.h&gt</code></pre>

<p>Pour définir une chaîne de caractères, il faut définir la taille de la chaîne de caractères. On pourra prendre une taille supérieure à la taille effective, car une fois définie, la taille ne pourra plus être modifiée. Dans ce cas, les emplacements non utilisés restent vides, mais occupent quand même de la place mémoire.</p>
<pre><code class="language-python">char chaine[100];
chaine[0] = 'b';
chaine[1] = 'o';
chaine[2] = 'n';
chaine[3] = 'j';
chaine[4] = 'o';
chaine[5] = 'u';
chaine[6] = 'r';
chaine[7] = '\0';</code></pre>

<p>On pourra également faire une déclaration dans une même accolade, et dans ce cas la taille du tableau est lue par le processeur et il est inutile de la spécifier :</p>
    <pre><code class="language-python">char chaine[] = {'b', 'o', 'n', 'j', 'o', 'u', 'r', '\0'};</code></pre>

<p>Dans la pratique, pour initialiser et afficher une chaîne de caractères, on utilisera plutôt :</p>
<pre><code class="language-python">char chaine[] = "bonjour";
printf("%s", chaine);</code></pre>

<p>Il n'est pas non plus nécessaire de définir la taille du tableau représentant la chaine. Par ailleurs, en utilisant l'élément %s, il s'affiche bien des lettres et non des chiffres comme on aurait pu le craindre.</p>

<p>Attention, cette méthode de déclaration-initialisation automatique d'une chaîne de caractères ne fonctionne qu'au moment de l'initialisation. Après il est impossible d'écrire <em>chaine = "bonjour"</em>. Il faudra ensuite utiliser une boucle pour définir la chaine.</p>

<p>Lors de l'initialisation d'une chaine, le saut de ligne sans marqueur n'est pas interprété par le compilateur :</p>
<pre><code class="language-python">strcpy(t1, "hello world"
    " et aussi bonjour");</code></pre>
<p>affichera : hello world et aussi bonjour</p>

<p>Puisque, vu d'un pointeur, une chaine est représentée par l'adresse de son premier élément, on peut définir une chaine en utilisant un pointeur :</p>
    <pre><code class="language-python">char *s = "bonjour";</code></pre>

<p>Notons qu'une chaîne de caractères n'est en principe pas modifiable. Toutefois, il est quand même possible de créer d'autres chaînes de caractères à partir d'une chaîne initiale.</p>

<table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille sans compter le \0</td><td><pre>strlen(chaine)</pre></td></tr>
    <tr><td>remplacement de chaineDestinataire par chaienAcopier</td><td><pre>strcpy(chaineDestinataire, chaineAcopier)</pre></td></tr>
    <tr><td>copie de chaineAcopier dans chaineDestinataire (qui est écrasée)</td><td><pre>strncpy(chaineDestinataire, chaineAcopier, 
                nbreCaracteresAcopier)</pre></td></tr>
    <tr><td>concaténer chaine1 dans chaine2</td><td><pre>strcat(chaine1, chaine2)</pre></td></tr>
    <tr><td>comparer deux chaînes</td><td><pre>strcmp(chaine1, chaine2)</pre></td></tr>
    <tr><td>renvoyer le reste de la chaine à partir du caractère a</td><td><pre>strchr(chaine, 'a')</pre></td></tr>
    <tr><td>renvoyer le reste de la chaine à partir de souschaine trouvé dans la chaine</td><td><pre>strstr(chaine, souschaine)</pre></td></tr>
    <tr><td>écrire une sous chaine dans une chaîne</td><td><pre>sprintf(chaine, sousChaine)</pre></td></tr>
</table>

<p>Attention, de façon contre-intuitive, la comparaison de deux chaines renvoie 0 si les chaînes sont identiques et un nombre positif ou négatif sinon.</p>

<p>Attention, comparer deux chaines avec un == ne compare pas les valeurs mais les adresses.</p>

<p>Attention à l'utilisation particulière des instructions ci-dessus qui utilisent systématiquement un pointeur.</p>
<pre><code class="language-python">char chaine[] = "bien le bonjour";
char *suiteChaine = NULL;
    
suiteChaine = strstr(chaine, "on");
if (suiteChaine != NULL){
    printf("%s", suiteChaine);
}</code></pre>



<!-- ===== SAISIE PAR L'UTILISATEUR ===== -->

<h3 id="saisie">Saisie par l'utilisateur</h3>

<p>Dans le cas d'une valeur numérique, on saisit la variable age sous forme d'adresse :</p>
<pre><code class="language-python">int age = 0;
printf("Quel âge avez-vous ?");
scanf("%d", &age);
printf("Vous avez %d ans, age);</code></pre>

<p>Dans le cas d'une chaine de caractères :</p>
<pre><code class="language-python">char nom[100];
printf("quel est votre nom?");
scanf("%s", nom);</code></pre>

<h4>Particularité de C</h4>

<p>Si le nombre saisi par l'utilisateur ne correspond pas au type, C ne lève pas une exception mais conserve la valeur initialisée de la variable. Si le type attendu est <strong>int</strong> mais que le type saisi est en fait <strong>float</strong>, C ne va toujours pas lever une exception mais tronquer le nombre saisi pour le transformer en entier.</p>



<!-- ===== BRANCHEMENT CONDITIONNEL ===== -->

<h3 id="condition">Branchement conditionnel</h3>

    <h4>La condition if</h4>

    <pre><code class="language-python">if (condition){
  instructions;
}
else{
  instructions;
}</code></pre>

    <p>Il est possible d'enchaîner les <strong>else</strong>.</p>

    <pre><code class="language-python">if (condition){
  instructions;
}
else if{
  instructions;
}
else{
  instructions;
}</code></pre>

    <h4>L'instruction switch</h4>

    <pre><code class="language-python">switch(maVariable){
  case valeur1:
    instruction;
    break;
  case valeur2:
    instruction;
    break;
  case valeur3:
    instruction;
    break;
  default:
    instruction;
}</code></pre>



<!-- ===== LES BOUCLES ===== -->

<h3 id="boucle"> Les boucles </h3>

   <h4>La boucle while</h4>

    <pre><code class="language-python">while (condition){
  instructions;
}</code></pre>

    <h4>La boucle for</h4>

    <pre><code class="language-python">for (int i=0; i<5; i++){
  instructions;
}</code></pre>

    <pre><code class="language-python">for elmt in chaine :
   instructions</code></pre>

    <h4>Particularité de Python</h4>

    <pre><code class="language-python">for lettre in chaine :
  if lettre in "aeiouy" :
    instructions</code></pre>

      <p>Le mot clé <strong>break</strong> permet d'interrompre une boucle et d'exécuter le code qui suit la boucle. Le mot clé <strong>continue</strong> permet de continuer une boucle en repartant du début du bloc sans exécuter ce qui suit <strong>continue</strong> dans le bloc.</p>



<!-- ===== LES FONCTIONS ===== -->

<h3 id="fonction">Les fonctions</h3>

<pre><code class="language-python">type maFonction(type parametre){
    instructions;
    return resultat
}</code></pre>

<p>Pour les fonctions qui ne renvoient pas de valeur (appelées procédures), on remplace le type par <strong>void</strong> et on renvoie <strong>return 0</strong>.</p>

<h4>Particularité de C</h4>

<p>Afin de pouvoir lire des fonctions se trouvant après la méthode main(), il faut d'abord déclarer ces fonctions en début de code derrière les préconditions en rajoutant le prototype des fonctions utilisées :</p>
<pre><code class="language-python">#include &ltstdio.h&gt
#include &ltstdio.h&gt
#include &ltstlib.h&gt
type maFonction(type parametre);</code></pre>
<p>En fait, il existe deux types de fichiers, les <em>.c</em> qui sont les codes sources et les <em>.h</em> appelés headers qui contiennent les prototypes des fonctions. Il faut importer ces fichiers <em>.h</em> en tant que préconditions dans les fichiers <em>.c</em> pour éviter d'avoir à rajouter tous les prototypes en début de code.</p>
<pre><code class="language-python">#include &ltstdio.h&gt
#include &ltstdio.h&gt
#include &ltstlib.h&gt
#include "monFichier.h"  # en reference a monFichier.c</code></pre>
<p>Notons que les fichiers sont importés sans chevron mais avec des guillemets alors que les packages sont importés avec chevrons.</p>

<p>Attention, cette règle d'emploi des prototypes est importante. Lorsqu'on appelle une fonction située dans monFichier.c depuis le fichier main.c il est nécessaire d'inclure le prototype de cette fonction dans les préconditions pour que le compilateur puisse vérifier que l'appel de la fonction est conforme à sa declaration. Il est donc nécessaire d'importer monFichier.h pour utiliser une fonction de monFichier.c</p>


<!-- ===== LES POINTEURS ===== -->

<h3 id="pointeur">Les pointeurs</h3>

<p>Un pointeur est une variable particulière contenant l'adresse d'une autre variable. Pour créer un pointeur, on rajoute le symbole * au type de variable :</p>
    <pre><code class="language-python">int* maVariable;</code></pre>

<p>Considérons la variable <em>nbre</em> à laquelle on affecte la valeur 12. L'adresse de la variable <em>nbre</em> est notée <em>&nbre</em> et donnée par le pointeur <em>pointeurSur_nbre</em>. L'instruction <em>*pointeurSur_nbre</em> permet d'accéder à la valeur de <em>nbre</em> à partir de son pointeur.</p>

<img src="images/pointeur.png" alt="pointeur">

<p>Le code suivant :</p>
<pre><code class="language-python">int nbre = 12;
int* pointeur = & nbre;
printf("%d \n", nbre);
printf("%p \n", &nbre);
printf("%p \n", pointeur);
printf("%d", *pointeur);</code></pre>

<p>affiche le résultat :</p>
<p>12 <br> 0x7ffedfc1da8c <br> 0x7ffedfc1da8c <br> 12</p>

<p>L'adresse d'une variable est écrite en hexadécimal. Il est par ailleurs important d'initialiser un pointeur avec la valeur NULL.</p>

<h3>Intérêt des pointeurs</h3>

<p>Le code suivant renvoie bien la valeur 2, mais il peut être avantageusement remplacé par un code utilisant des pointeurs. Rappelons que l'utilisation de variables globales reste à proscrire.</p>
<pre><code class="language-python">int modification(int parametre);

int main(int argc, char* argv[]) {
    
    int maVariable = 0;
    maVariable = modification(maVariable);
    printf("%d", maVariable);
    
    return (EXIT_SUCCESS);
}

int modification(int parametre){
    parametre = parametre+2;
    return parametre;
}</code></pre>

<p>Si on modifie ce code en utilisant un pointeur, on parvient à changer directement la valeur de maVariable bien qu'elle ne soit pas globale. On obtient dans ce cas 2 :</p>
<pre><code class="language-python">void modification(int* parametre);

int main(int argc, char* argv[]) {
    
    int maVariable = 0;
    modification(&maVariable);
    printf("%d", maVariable);
    
    return (EXIT_SUCCESS);
}

void modification(int* pointeurParametre){
    *parametre = *parametre+2;
}</code></pre>

<h4>Utilisation des pointeurs dans les fonctions</h4>

<p>Il est rarement judicieux de déclarer une variable globale. Pourtant C propose de modifier une variable sans la déclarer globale, mais en travaillant sur son adresse à l'aide du pointeur qui lui est associé. L'exemple suivant ne permet pas d'inverser la valeur des variables a et b :</p>
<pre><code class="language-python">void permuter(int a, int b);

int main(int argc, char* argv[]) {
    
    int a = 10;
    int b = 20;
    
    permuter(a, b);
     
    printf("%d, %d", a, b);
    
    return (EXIT_SUCCESS);
}

void permuter(int a, int b){
    
    int c;
    
    c = a;
    a = b;
    b = c; 
}</code></pre>

<p>En revanche, l'utilisation des pointeurs *a et *b permet d'obtenir le résultat voulu :</p>

<pre><code class="language-python">void permuter(int *a, int *b);

int main(int argc, char* argv[]) {
    
    int a = 10;
    int b = 20;
    
    permuter(&a, &b);
     
    printf("%d, %d", a, b);
    
    return (EXIT_SUCCESS);
}

void permuter(int *a, int *b){
    
    int c;
    
    c = *a;
    *a = *b;
    *b = c; 
}</code></pre>

<p>En fait, l'utilisation d'un tableau pour stocker le résultat de la fonction permuter ne fonctionne pas en C. Ainsi le code suivant lève une exception.</p>
<pre><code class="language-python">int[2] inverse(int a, int b);

int main(int argc, char** argv) {

    int a = 10;
    int b = 20;
    int[2] tab;
    
    tab = inverse(a, b);
    printf("%d, %d", tab[0], tab[1]);
    
    return (EXIT_SUCCESS);
}

int[2] inverse(int a, int b){
    int c = a;
    int[2] tab;
    
    a = b;
    b = c;
  
    tab[0] = a;
    tab[1] = b;
    return tab;
}</code></pre>

<p>L'utilisation des pointeurs est donc systématique en C car on ne peut pas comme dans d'autres langages écrire une fonction qui renvoie un tableau. Ainsi, les fonctions ne renvoient qu'un unique élément.</p>



<!-- ===== LE PACKAGE MATH ===== -->

<h3 id="math">Le package math.h</h3>

    <pre><code class="language-python">#include &ltmath.h&gt</code></pre>
<p></p>

<table>
    <tr><th>Instruction</th><th>Effet obtenu</th></tr>
    <tr><td>floor(x)</td><td>plus grand entier inférieur ou égal à x, renvoie un double</td></tr>
    <tr><td>ceil(x)</td><td>plus petit entier supérieur ou égal à x, renvoie un double</td></tr>
    <tr><td>fabs(x)</td><td>valeur absolue de x, renvoie un double</td></tr>
    <tr><td>exp(x)</td><td>exponentielle de x, renvoie un double</td></tr>
    <tr><td>log(x)</td><td>logarithme en base e de x, renvoie un double</td></tr>
    <tr><td>pow(x, y)</td><td>x puissance y</td></tr>
    <tr><td>sqrt(x)</td><td>racine carrée de x, renvoie un double</td></tr>
    <tr><td>pi</td><td>pi = 3,14</td></tr>
    <tr><td>cos(x)</td><td>cosinus de x pour x en radians, renvoie un double</td></tr>
    <tr><td>sin(x)</td><td>sinus de x pour x en radians, renvoie un double</td></tr>
    <tr><td>tan(x)</td><td>tangente de x pour x en radians, renvoie un double</td></tr>
    <tr><td>acos(x)</td><td>arc cosinus de x en radians, renvoie un double</td></tr>
    <tr><td>asin(x)</td><td>arc sinus de x en radians, renvoie un double</td></tr>
    <tr><td>atan(x)</td><td>arc tangente de x en radians, renvoie un double</td></tr>
  </table>

</section> <!-- END CONTENU -->
</section> <!-- END GRAND CONTENU -->
