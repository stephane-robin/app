<!-- TABLE MATIERES -->
<aside id="table_matieres">
  <nav id="table_matiere">
    <a href="#py_generalites">Structure du code</a>
      <a href="#py_communiquer">Communiquer avec l'utilisateur</a>
      <a href="#py_variable">Les variables</a>
      <a href="#py_chaine">Chaînes de caractères</a>
      <a href="#py_liste">Les listes</a>
      <a href="#py_tableau">Les tableaux</a>
      <a href="#py_dictionnaire">Les dictionnaires</a>
      <a href="#py_condition">Les conditions</a>
      <a href="#py_boucle">Les boucles</a>
      <a href="#py_input">Entrées/sorties</a>
      <a href="#py_fonction">Les fonctions</a>
      <a href="#py_exception">Gestion des exceptions</a>
      <a href="#py_objet">Programmation objet</a>
      <a href="#py_package">Les packages</a>
    <a href="#py_interface">Interfaces graphiques</a>
    <a href="#py_environnement">Environnements de travail</a>
      <a href="#py.sub">subprocess et les lignes de commande</a>
    <a href="#py_django">Le framework Django</a>
        <a href="#py_pep">Respect du PEP8</a>
        <a href="">Tester le code</a>
  </nav>
</aside>

<!-- GRAND CONTENU -->
<section id="grandContenu">

<!-- BANDEAU -->
  <h2>PYTHON</h2>

    <div id="bandeau_sousTitre">
      <p>S. Robin (mis à jour le 01 Mar. 2021)</p>
    </div>

  <div id="bandeau_contenu">
    <p>L'essentiel du savoir-faire</p>
  </div>

  <div id="bandeau_controle">
  </div>

  <!-- CONTENU -->
  <section id="contenu">



  <!-- STRUCTURE ======================================================== -->

  <h3 id="py_generalites"> Structure du code Python </h3>

  <p>Les fichiers Python ont pour extension <em>.py</em> et sont appelés des modules. Contrairement à Java, ceux-ci peuvent
  contenir plusieurs classe (et non pas une seule), ou constituer un script sans aucune classe.</p>

  <p>Les projets Python sont donc organisés en modules, suivant une architecture objet ou procédurale.</p>

  <p>Les commentaires sont indiqués à l'aide de <strong>#</strong> pour une seule ligne ou <strong>"""   """</strong> pour plusieurs lignes en début de fonction ou de module.</p>

  <p>En Python, les blocs ne sont pas encadrés par des <strong>{}</strong> comme dans la plupart des langages, ce sont les indentations qui indiquent à l'interpréteur le début et la fin d'un bloc. En conséquence, il est important de respecter toujours la même procédure d'indentation. On utilisera 4 espaces plutôt qu'une tabulation pour exprimer une indentation, ceci afin d'assurer une bonne portabilité du code.</p>

  <p>Les mots clés Python réservés, donc à ne pas utiliser comme nom de variable ou de fonction sont les suivants: <em>and, or, del, from, none, as, global, nonlocal, try, assert, else, if, elif, not, while, for, except, import, with, class, true, false, in, pass, yield, continue, break, finally, is, raise, def, lambda, return</em>.</p>

<p>Les projets Python peuvent se structurer en modules ou en classes dans le cas de la programmation objet.</p>



  <h4>Exécution d'un module à partir du terminal</h4>

    <p>L'exécution d'un module Python en utilisant le bash s'effectue de la façon suivante à partir du dossier contenant le module :</p>
    <pre><code class="language-svg">python [nom_module.py]</code></pre>

    <p>L'exécution d'un package en utilisant le bash s'effectue de la façon suivante à partir du dossier courant :</p>
    <pre><code class="language-svg">python -m [nom_package]</code></pre>

  <p>Pour connaître la version de Python utilisée : </p>
  <pre><code class="language-svg">python --version</code></pre>

  <p>Pour connaître le chemin vers le dossier Python :</p>
  <pre><code class="language-svg">which python</code></pre>

  <p>Il est souvent nécessaire de placer en début de code le chemin absolu de l'interpréteur (ici 3.7 représente la version de Python), et de préciser l'encodage UTF-8 :</p>
  <pre><code class="language-svg">#!/usr/bin/env python3
# -*-coding:Utf-8 -*</code></pre>

  <p>L'installation de l'éditeur JetBrains PyCharm-community se fait sur Linux grâce à l'instruction bash :</p>
  <pre><code class="language-svg">sudo snap install pycharm-community --classic</code></pre>
  <p>Lors de la création d'un projet dans PyCharm, il faut spécifier l'environnement dans lequel on travaille (par exemple virtualenv ou conda) et définir le chemin de l'interpréteur Python lié à cet environnement.</p>





  <h4>Particularité du système Windows</h4>

  <p>Préciser l'encodage peut s'avérer nécessaire sous Windows. Par ailleurs, il faut mettre en pause le programme en fin d'exécution afin de pouvoir lire le résultat.</p>
  <pre><code class="language-svg"># -*-coding:Latin-1 -*
import os
# le programme se trouve ici
os.system("pause")</code></pre>











  <!-- ======== LES METHODES DE COMMUNICATION ========= -->

  <h3 id="py_communiquer">Communiquer avec l'utilisateur</h3>

  <h4>Hello world</h4>

  <p>Commençons par le traditionnel "Hello world". Contrairement à beaucoup de langages, Python n'utilise pas de <strong>;</strong> à la fin de chaque instruction. Il le remplace par un retour à la ligne. Notons que les accolades symbolisant un bloc sont remplacées par une indentation.</p>
  <pre><code class="language-javascript">print("Hello World");</code></pre>

  <p>A noter que <em>print</em> entraîne systématiquement un retour à la ligne, contrairement à certains autres langages où il faut rajouter ln
    pour aller à la ligne. Pour éviter un retour à la ligne, on utilise l'instruction print("hello", end = "")</p>


  <h4>Afficher une valeur</h4>

  <p>La fonction print() permet d'afficher une chaîne de caractères et accepte les paramètres suivants :</p>
    <ul>
  <li>end='-' pour préciser ce qu'il faut afficher à la fin de la chaine ou pour afficher sur une même ligne avec end=''</li>
  <li>sep='-' pour préciser le séparateur entre plusieurs chaînes.</li>
</ul>

  <p>Python accepte les template litteral, suivant trois formats du plus ancien au plus moderne :</p>

  <pre><code class="language-python">name = "Bob"
"Hello %s" % name</code></pre>

  <pre><code class="language-python">name = "Bob"
"Hello {}".format(name)</code></pre>

  <pre><code class="language-python">name = "Bob"
f"Hello {name}"</code></pre>

  <p>L'intérêt du template litteral, outre sa structure simple, est qu'il n'est pas nécessaire de transformer name en
  string dans le cas où il s'agit d'un float pour pouvoir le concaténer avant de l'afficher. Cela simplifie donc la
  compréhension du code.</p>


  <h4>Saisie d'une valeur par l'utilisateur</h4>

  <pre><code class="language-python">nom = input("Quel est votre nom ?");
print("Bonjour ",nom);</code></pre>

  <p></p>

  <fieldset><legend>ATTENTION </legend>
    <p>La valeur saisie est systématiquement de type <em>String</em>. Il convient donc de la transformer en nombre le cas échéant.</p>
  </fieldset>

  <pre><code class="language-python">age = int(input("Quel est votre âge ?"))
print("Dans deux ans vous aurez ", age+2)</code></pre>




<!------LES PACKAGES------------->

  <h3 id="py_package">Les Packages</h3>

<!-- ===== IMPORTER UN PACKAGE ===== -->

<h4 id="py_import_package">Installer et importer un package</h4>

  <p>Pour installer un package, si la version de Python par défaut est Python3, on utilise l'instruction pip en ligne de
    commande, si la version de Python par défaut est Python2, on utilise l'instruction pip3 en ligne de commande pour forcer
    l'ordinateur à pointer vers Python3 :</p>
  <pre><code class="language-python">pip install nom_package</code></pre>

  <p>De la même façon, pour désinstaller un package :</p>
  <pre><code class="language-python">pip uninstall nom_package</code></pre>

  <p>Ensuite, pour importer un package dans le code, on peut utiliser l'instruction :</p>
  <pre><code class="language-python">import nomPackage</code></pre>

  <p>Dans ce cas, il faudra appeler chaque fonction en utilisant <em>nomPackage</em> comme préfixe.</p>
  <pre><code class="language-python">nomPackage.maFonction(5)</code></pre>

  <p>Pour éviter cela, On peut importer un package en précisant un préfixe :</p>
  <pre><code class="language-python">import nomPackage as p</code></pre>

<p>Chaque fonction du package sera ensuite appelée avec ce même préfixe <em>np</em>.</p>
  <pre><code class="language-python">p.maFonction(5)</code></pre>

<p>Lorsqu'il n'y a aucun risque de confusion entre les fonctions de différents packages, on peut utiliser l'instruction
  suivante qui évite d'ajouter un préfixe à chaque instruction. C'est pratique dans un script, mais déconseillé dans un
  code complexe pour réduire les erreurs et accroître la scalabilité du code.</p>

  <pre><code class="language-python">from nomPackage import *</code></pre>

  <p>Pour importer uniquement un module d'un package, par exemple :</p>

  <pre><code class="language-python">import matplotlib.pyplot as plt</code></pre>



  <h4>Particularité Python pour l'importation d'un package</h4>

  <p>Pour éviter qu'une méthode main() ne se lance à l'importation, on peut utiliser une condition qui lance la méthode uniquement si elle est appelée :</p>

  <pre><code class="language-python">if __name__ == "__main__":
  main()</code></pre>

  <p>Parmi les packages importants, on trouve Matplotlib utilisé pour les graphiques, Numpy utilisé pour manipuler des séries de nombres, Pandas utilisé pour utiliser des données sous une forme de tableur.</p>



    <!-- ===== LES MODULES ESSENTIELS  ===== -->

    <h4>Les packages et modules essentiels</h4>

    <p>Python étant parcitulièrement utilisé dans le milieu scientifique et
      mathématique, le module math ainsi que le module numpy sont essentiels</p>

    <h4>Le module random</h4>

    <pre><code class="language-python">import random as rd</code></pre>

    <p>La méthode .random() génère un nombre pseudo-aléatoire compris entre 0 et 1.</p>

    <p>La méthode .randrange(5, 10, 2) génère un nombre pseudo-aléatoire compris entre 5 et 10 exclus, avec un écart de 2
      entre chaque valeur. Sans le 3ème paramètre, la valeur par défaut est 1.</p>

    <p>La méthode <strong>randint(4, 7)</strong> renvoie un entier compris entre 4 et 7 inclus.</p>

    <p>Pour remplir une liste de 10 éléments à l'aide de valeurs comprises entre 0 et 50 prises au hasard :</p>
    <pre><code class="language-python">liste = (rd.randrange(50) for i in range(10))</code></pre>

    <p>Pour remplir un tableau de 10 éléments à l'aide de valeurs comprises entre 0 et 50 prises au hasard :</p>
    <pre><code class="language-python">tableau = [rd.randrange(50) for i in range(10)]</code></pre>

    <p>La méthode choice(["a", "b", "c"]) renvoie un élément choisit au hasard de la liste ["a", "b", "c"].</p>

    <p>La méthode shuffle(liste) mélange les éléments d'une liste en modifiant cette liste. Elle ne renvoie rien.</p>


    <h4>Le module math</h4>

    <pre><code class="language-python">from math import *</code></pre>

    <table>
      <tr><th>Instruction</th><th>Effet obtenu</th></tr>
      <tr><td>floor(x)</td><td>plus grand entier inférieur ou égal à x</td></tr>
      <tr><td>ceil(x)</td><td>plus petit entier supérieur ou égal à x</td></tr>
      <tr><td>trunc(x)</td><td>troncature de x</td></tr>
      <tr><td>fabs(x)</td><td>valeur absolue de x</td></tr>
      <tr><td>factorial(x)</td><td>factorielle de x. Lève une exception ValueError si x n'est pas entier ou si x est négatif</td></tr>
      <tr><td>fsum(maListe)</td><td>valeur exacte de la somme des valeurs d'une liste</td></tr>
      <tr><td>gcd(a, b)</td><td>pgdc de a et b</td></tr>
      <tr><td>exp(x)</td><td>exponentielle de x</td></tr>
      <tr><td>log1p(x)</td><td>logarithme en base e de x</td></tr>
      <tr><td>pow(x, y)</td><td>x puissance y, renvoie un float</td></tr>
      <tr><td>x**y</td><td>x puissance y, renvoie un int</td></tr>
      <tr><td>sqrt(x)</td><td>racine carrée de x</td></tr>
      <tr><td>acos(x)</td><td>arc cosinus de x en radians</td></tr>
      <tr><td>asin(x)</td><td>arc sinus de x en radians</td></tr>
      <tr><td>atan(x)</td><td>arc tangente de x en radians</td></tr>
      <tr><td>cos(x)</td><td>cosinus de x pour x en radians</td></tr>
      <tr><td>sin(x)</td><td>sinus de x pour x en radians</td></tr>
      <tr><td>tan(x)</td><td>tangente de x pour x en radians</td></tr>
      <tr><td>degrees(x)</td><td>convertit l'angle x de radians en degrés</td></tr>
      <tr><td>radians(x)</td><td>convertit l'angle x de degrés en radians</td></tr>
      <tr><td>acosh(x)</td><td>arc cosinus hyperbolique de x</td></tr>
      <tr><td>asinh(x)</td><td>arc sinus hyperbolique de x</td></tr>
      <tr><td>atanh(x)</td><td>arc tangente hyperbolique de x</td></tr>
      <tr><td>cosh(x)</td><td>cosinus hyperbolique de x</td></tr>
      <tr><td>sinh(x)</td><td>sinus hyperbolique de x</td></tr>
      <tr><td>tanh(x)</td><td>tangente hyperbolique de x</td></tr>
      <tr><td>pi</td><td>pi = 3,14</td></tr>
      <tr><td>e</td><td>e = 2,71</td></tr>
    </table>

    <p>En Python les angles sont exprimés en radian par défaut.</p>

    <p>pi et e sont les deux constantes mathématiques connues du package math.</p>


    <h4>Le module fractions</h4>

    <pre><code class="language-python">from fractions import Fraction</code></pre>

    <p>Un objet de type Fraction est défini de la façon suivante : Fraction(numérateur, dénominateur). Une fois définie,
      une fraction est affichée systématiquement sous sa forme simplifiée.</p>

    <p>La classe Fraction accepte les opérations élémentaires +, -, *, / et permet de conserver une excellente précision de calcul.</p>


    <h4>Le module Numpy</h4>

    <pre><code class="language-python">import numpy as np</code></pre>

    <p>Numpy est utilisé pour manipuler des séries de nombres. En particulier, il permet de traiter des listes de nombres comme des tableaux de nombres.</p>

    <pre><code class="language-python">liste_numpy = np.array([10, 20, 30])
liste_divisee = liste_numpy/2</code></pre>

    <p>Numpy permet notamment de faire la somme des éléments de la liste :</p>
    <pre><code class="language-python">liste_numpy.sum()</code></pre>


    <h4>Le package MatPlotLib</h4>

    <p>MatPlotLib est utilisé pour représenter des données en deux dimensions, i.e. pour créer des schémas, des graphiques
      et des spectres. Ce package comprend notamment le module Pyplot qui permet de créer des graphiques en couleur.</p>




    <!-- ==== CREER UN PACKAGE ===== -->

    <h4 id="py_creer_package">Créer un package</h4>

    <p>Un package Python est organisé en fichiers ou classes, qui sont regroupées dans des modules. Les noms des packages et des modules seront écrits en minuscule et peuvent contenir des underscore. La structure à adopter est la suivante :</p>
    <pre>librairie // racine du package
  librairie/  // module Python
    __init__.py
    fichier.py
    main.py
    .gitignore
  setup.py</pre>

    <p>Le fichier .gitignore devra contenir :</p>
    <pre># compiled python modules
*.pyc

# setup tools distribution folder
/dist/

#python egg metadata, regenerated from source files by setuptools
/*.egg-info</pre>

    <p>Le fichier setup.py contient les commandes suivantes :</p>

    <pre><code class="language-python">from setuptools import setup

setup(name = "librairie",
  version = "1.0",
  description = "ma librairie",
  url = "http://github/librairie",
  author = "bob",
  author_email = "bob@gmail.com",
  licence = "xxx",
  packages = ['librairie'],
  install_requires = [ # list of dependancies
    'nomPakage',
  ],
  zip_safe = False)</code></pre>

    <p>L'installation d'un package en local sur Linux se fait avec la commande pip install librairie.</p>

    <p>Pour publier un package sur PyPI, il faut utiliser la commande python setup.py register</p>





    <!-- ===== CREER UN PACKAGE ===== -->

    <h3 id="py_package2">Créer un package avec Poetry</h3>

    <p>Il est possible de créer manuellement les fichiers build, manifestes et dépendances en utilisant pip ou conda.
      Toutefois, la gestion des compatibilités des dépendances n'est pas toujours assurée et la publication sur PyPI peut
      s'avérer impossible. Poetry est un outil complet ... Pour installer Poetry il faut écrire le script en ligne de commande :</p>

    <pre><code class="language-python">curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python3</code></pre>

    <p>Ce script installe Poetry et il est nécessaire de relancer le Terminal pour modifier automatiquement le system PATH. On peut vérifier la bonne installation avec la
      commande :</p>

    <pre><code class="language-python">poetry --version</code></pre>

    <p>Pour générer un package, il ne faut pas créer de répertoire vide mais écrire directement :</p>

    <pre><code class="language-python">poetry new mon_package</code></pre>

    <p>qui crée le package dans un répertoire du même nom.</p>

    <p>La structure du package ressemble ainsi à ceci :</p>

    <img src="poetry.png" alt="poetry"/>

    <p>Il faut ensuite ajouter des dépendances au fichier .toml dont la version sera enregistrée dans un fichier .lock. Bien
      qu'il soit possible de les ajouter manuellement, il est préférable d'utiliser la commande suivante qui gère la compatibilité
      des dépendances :</p>

    <pre><code class="language-python">poetry add un_module</code></pre>






    <!-- ===== LES VARIABLES ===== -->

<h3 id="py_variable">Les types de variables</h3>

  <p>Python est un langage à typage dynamique, i.e. qu'il identifie lui-même les types de variables et autorise les changements de type. La déclaration des variables n'est donc pas nécessaire. L'instruction <strong>int(chaine)</strong> permet de transformer un <em>String</em> en nombre <em>si cela est possible</em> alors que l'instruction <strong>str(nombre)</strong> permet de transformer un nombre en <em>String</em>.</p>
  <p>Par ailleurs, Python est un langage fortement typé, i.e. qu'il ne convertit pas automatiquement les types de variables, mais requiert une instruction spécifique. Ainsi, la concaténation d'un <em>String</em> avec un entier lève une exception et ne transforme pas l'entier en <em>String</em>.</p>
  <p>Pour tester le type d'une variable, on utilise l'instruction <strong>type(maVariable)</strong>. Cette instruction lève une exception si maVariable n'existe pas. En revanche, elle renvoie le type si maVariable a été déclarée mais reste vide.</p>

  <table>
    <tr><th>Types</th><th>Mots-clés</th></tr>
    <tr><td>entier</td><td>int</td></tr>
    <tr><td>nombre décimal</td><td>float</td></tr>
    <tr><td>nombre complexe</td><td>complex</td></tr>
    <tr><td>chaîne de caractères</td><td>str</td></tr>
    <tr><td>booléen</td><td>bool</td></tr>
  </table>

  <p>Les booléens prennent les valeurs <strong>True</strong> et <strong>False</strong>.</p>
  <p>Il n'existe pas de type StringBuffer comme en Java pour représenter les chaînes de caractères modifiables.</p>

  <h4>Particularité de Python</h4>

  <p>Python permet de permuter simplement les valeurs de deux variables sans passer par une troisième.</p>
  <pre><code class="language-python">a = 2
b = 5
a, b = b, a</code></pre>

  <h4> Les principales opérations </h4>

  <table>
    <tr><th>Opérations</th><th>Symboles</th></tr>
    <tr><td>addition</td><td>+</td></tr>
    <tr><td>soustraction</td><td>-</td></tr>
    <tr><td>multiplication</td><td>*</td></tr>
    <tr><td>division</td><td>/</td></tr>
    <tr><td>modulo</td><td>%</td></tr>
    <tr><td>partie entière d'une division</td><td>//</td></tr>
    <tr><td>concaténation</td><td>+</td></tr>
    <tr><td>affectation</td><td>=</td></tr>
    <tr><td>égalité</td><td>==</td></tr>
    <tr><td>incrémentation</td><td>++</td></tr>
    <tr><td>décrémentation</td><td>--</td></tr>
    <tr><td>ET logique</td><td>and</td></tr>
    <tr><td>OU logique</td><td>or</td></tr>
    <tr><td>NON logique</td><td>! ou  not</td></tr>
  </table>

  <h4>Les opérateurs de comparaison</h4>

  <table>
    <tr><th>Signification</th><th>Opérateurs</th></tr>
    <tr><td>égalité</td><td>==</td></tr>
    <tr><td>égalité (valeur et type)</td><td>===</td></tr>
    <tr><td>différent</td><td>!=</td></tr>
    <tr><td>inférieur</td><td><</td></tr>
    <tr><td>inférieur ou égal</td><td><=</td></tr>
    <tr><td>supérieur</td><td>></td></tr>
    <tr><td>supérieur ou égal</td><td>>=</td></tr>
  </table>

  <h4>Les constantes</h4>

  <p>Les constantes n'existent pas en Python. On utilise généralement des variables globales qu'on ne modifie pas.</p>




  <!-- ===== BRANCHEMENT CONDITIONNEL ===== -->

  <h3 id="py_condition">Branchement conditionnel</h3>

    <h4>La condition if</h4>

    <pre><code class="language-python">if condition :
  instructions
else :
instructions</code></pre>

    <h4>Particularités de Python</h4>

    <p>L'instruction <strong>elif</strong> est la contraction de l'instruction <strong>else if</strong>.</p>

    <pre><code class="language-python">if condition :
  instructions
elif condition :
  instructions
else :
  instructions</code></pre>
    
    <p>L'instruction <strong>switch</strong> n'existe pas de façon native en Python.</p>



  <!-- ===== LES BOUCLES ===== -->

  <h3 id="py_boucle"> Les boucles </h3>

  <h4>La boucle for</h4>

  <p>Pour une répétition allant de 0 à 4 :</p>
    <pre><code class="language-python">for i in range(0, 5):
  instructions</code></pre>

  <p>Pour parcourir tous les éléments d'une liste ou d'un tableau:</p>
  <pre><code class="language-python">for elmt in liste:
  print(elt) # ou une quelconque instruction sur elt</code></pre>

  <p>Pour parcourir tous les éléments d'une chaîne de caractères:</p>
    <pre><code class="language-python">for elmt in chaine:
  print(elt) # ou une quelconque instruction sur elt</code></pre>

    <h4>Particularité de Python</h4>

    <pre><code class="language-python">for lettre in chaine :
  if lettre in "aeiouy" :
  instructions</code></pre>

  <h4>La boucle while</h4>

  <pre><code class="language-python">while condition :
  instructions</code></pre>

  <p>Le mot clé <strong>break</strong> permet d'interrompre une boucle et d'exécuter le code qui suit la boucle. Le mot clé <strong>continue</strong> permet de sauter le tour de boucle courant puis de continuer à exécuter la boucle.</p>





    <!-- ===== MANIPULER DES CHAINES DE CARACTERES ===== -->

    <h3 id="py_chaine">Manipuler des chaînes de caractères</h3>

    <p>L'indice du 1er caractère d'une chaîne est 0. Pour échapper une apostrophe ou un guillemet, on utilise le signe <strong>\</strong>.<p>

    <table>
      <tr><th>Propriétés</th><th>Codes</th></tr>
      <tr><td>taille</td><td><pre>len(chaine)</pre></td></tr>
      <tr><td>élément d'indice i</td><td><pre>chaine[i]</pre></td></tr>
      <tr><td>dernier élément</td><td><pre>chaine[-1]</pre></td></tr>
      <tr><td>convertir en minuscules</td><td><pre>chaine.lower()</pre></td></tr>
      <tr><td>convertir en majuscules</td><td><pre>chaine.upper()</pre></td></tr>
      <tr><td>mettre en majuscule le 1er caractère d'une chaîne</td><td><pre>chaine.capitalize()</pre></td></tr>
      <tr><td>nombre de "d" dans la chaîne</td><td><pre>chaine.count("d")</pre></td></tr>
      <tr><td>remplacement de "d" par "a"</td><td><pre>chaine.replace("d", "a")</pre></td></tr>
      <tr><td>enlever les espaces au début et à la fin d'une chaine</td><td><pre>chaine.strip()</pre></td></tr>
      <tr><td>extrait une sous-chaîne, comprenant la lettre d'indice 3 jusqu'à la lettre d'indice 5 incluse</td><td><pre>chaine[3:6]</pre></td></tr>
      <tr><td>extrait une sous-chaîne, comprenant la lettre d'indice 3 jusqu'à la lettre d'indice 5 incluse</td><td><pre>chaine[3:6]</pre></td></tr>
      <tr><td>comparaison</td><td>===</td></tr>
      <tr><td>concaténation</td><td>+</td></tr>
      <tr><td>retour à la ligne</td><td>\n</td></tr>
      <tr><td>tabulation</td><td>\t</td></tr>
      <tr><td>transformer une chaîne en liste élément par élément</td><td><pre>liste = chaine.split()</pre></td></tr>
      <tr><td>transformer une chaîne avec le séparateur - en liste</td><td><pre>liste = chaine.split("-");</pre></td></tr>
      <tr><td>transformer une liste en chaîne contenant le séparateur - </td><td><pre>chaine = "-".join(maListe)</pre></td></tr>
      <tr><td>recherche de "non" dans une chaine. Renvoie -1  si le caractère recherché ne se trouve pas dans la chaîne</td><td><pre>chaine.indexOf("non")</pre></td></tr>
      <tr><td>retour à la ligne</td><td>\n</td></tr>
      <tr><td>test si le contenu de la chaîne est numérique. Renvoie un booléen</td><td><pre>chaine.isnumeric()</pre></td></tr>
    </table>

    <p>L'utilisation d'un indice qui n'existe pas dans la chaîne lève une exception de type <em>IndexError</em>.</p>
    <p>Il n'est pas possible de modifier un caractère d'une chaîne de la façon suivante <em>chaine[4] = "Antoine"</em>. Il s'agit en fait d'une protection des chaînes qui pourront être modifiées par instruction explicite du développeur.</p>

    <p>Python utilise indistinctement " ou ' pour encadre une chaîne de caractères, et ne distingue pas les caractères isolés comme Java.</p>

  <h4>Parcourir une chaîne de caractères élément par élément</h4>

    <pre><code class="language-python">for(let i=0; i&lt chaine.length; i++){
  chaine[i];
}</code></pre>

    <h4>Template literal</h4>

    <p>Python permet d'inclure des expressions dans une chaîne de caractères appelées <em>template literal</em>. Pour cela, il faut définir les emplacement avec <strong>{}</strong> et utiliser la méthode <strong>format()</strong>.</p>
    <pre><code class="language-python">{} est le fils de {}.format("Antoine", "Albert")</code></pre>

    <h4>Caster une chaîne de caractères</h4>

    <p>Il est possible de caster une chaîne de caractères lorsque ceux-ci s'apparentent à des nombres. Pour cela, on utilise
      les méthodes int() et float(). Cela s'avère utile lorsqu'on demande à un utilisateur de saisir un nombre. Ce dernier est
      nativement enregistré au format d'une chaîne de caractères qu'il faut caster pour pouvoir appliquer des opérations numériques.</p>

    <pre><code class="language-python">chaine = "12"
nombre = int(chaine)</code></pre>




<!-- ===== LES TABLEAUX ===== -->

<h3 id="py_tableau">Les tableaux</h3>

  <p>Les tableaux (appelés tuples en Python) contiennent des éléments dont le nombre de bouge pas. On peut toutefois changer ces éléments. Un tableau est considéré comme un type élémentaire en Python.</p>

  <p>On peut créer un tableau de la manière suivante :</p>
  <pre><code class="language-python">tab = (element1, element2)</code></pre>

  <p>L'indice du 1er élément d'un tableau est 0. Attention, on ne modifie pas les éléments d'un tuple, qui sont par
  définition immuables.</p>

  <h4>Propriétés d'un tableau</h4>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>len(tab)</pre></td></tr>
    <tr><td>élément d'indice i</td><td><pre>tab[i]</pre></td></tr>
    <tr><td>dernier élément d'une liste</td><td><pre>tab[-1]</pre></td></tr>
    <tr><td>indice d'un élément</td><td><pre>tab.index(element)</pre></td></tr>
  </table>



<!-- ===== LES LISTES ===== -->

<h3 id="py_liste">Les listes</h3>

  <p>Les listes contiennent des éléments dont le nombre peut varier, mais
    l'indice du 1er élément est 0. Les listes sont compatibles avec les
    dictionnaires en ce sens qu'une liste peut contenir des dictionnaires et
  vice versa.</p>

  <p>On peut créer une liste de la manière suivante :</p>
  <pre><code class="language-python">liste = [element1, element2, element3]</code></pre>

  <p>En Python on peut stocker des éléments de différents types dans une liste.</p>
  <pre><code class="language-python">maListe = ["Antoine", 12, false]</code></pre>

  <p>En Python, l'appel à un indice ne figurant pas dans la liste conduit à une exception de la forme <em>IndexError: list index out of range</em>.</p>

  <p>Pour créer une liste vide</p>
  <pre><code class="language-python">maListe = list()</code></pre>

  <h4>Propriétés d'une liste</h4>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>len(maListe)</pre></td></tr>
    <tr><td>élément d'indice i</td><td><pre>maListe[i]</pre></td></tr>
    <tr><td>dernier élément d'une liste</td><td><pre>maListe[-1]</pre></td></tr>
    <tr><td>modifier l'élément d'indice i</td><td><pre>maListe[i] = nouvelleValeur</pre></td></tr>
    <tr><td>indice d'un élément</td><td><pre>maListe.index(element)</pre></td></tr>
    <tr><td>ajout d'un élément à la fin d'une liste</td><td><pre>maListe.append(element)</pre></td></tr>
    <tr><td>ajout d'un élément au début d'une liste'</td><td><pre>maListe.unshift(element)</pre></td></tr>
    <tr><td>ajout d'un élément à l'indice i</td><td><pre>maListe.insert(i, element)</pre></td></tr>
    <tr><td>concaténation de maListe1 et maListe2 enregistrée dans maListe1</td><td><pre>maListe1.extend(maListe2)</pre></td></tr>
    <tr><td>suppression du dernier élément et renvoi de sa valeur</td><td><pre>maListe.pop()</pre></td></tr>
    <tr><td>suppression de l'élément d'indice i</td><td><pre>del maListe[i]</pre></td></tr>
    <tr><td>suppression d'un élément défini par sa valeur, seul le 1er element de cette valeur est supprimé</td><td><pre>maListe.remove(element)</pre></td></tr>
    <tr><td>tri d'une liste d'entiers de façon ascendante (cette fonctionnalité modifie la liste d'origine)</td><td><pre>maListe.sort()</pre></td></tr>
    <tr><td>tri d'une liste d'entiers de façon descendante (cette fonctionnalité modifie la liste d'origine)</td><td><pre>maListe.sort(reverse=True)</pre></td></tr>
    <tr><td>inversion des éléments d'une liste</td><td><pre>maListe.reverse()</pre></td></tr>
  </table>

  <p>Une liste vide a pour taille 0. </p>

  <h4>Parcourir une liste</h4>

  <p>Si on souhaite afficher une liste sans mise en forme particulière, l'utilisation de <strong>print</strong> est suffisante.</p>
  <pre><code class="language-python">print(maListe)</code></pre>

  <p>On peut également afficher les éléments de maListe les uns à la suite des autres.</p>

  <pre><code class="language-python">for i in range(len(maListe)):
    print(maListe[i])</code></pre>

  <p>Python offre la possibilité de parcourir une liste sans référence aux indices, mais en utilisant un itérateur des éléments qui composent la liste. Ceci correspond à l'instruction <strong>forEach</strong> d'autres langages.</p>
  <pre><code class="language-python">for elmt in maListe:
    print(elmt)</code></pre>

  <p>Python offre deux autres possibilités pour afficher les éléments d'une liste :</p>

  <pre><code class="language-python">for value in enumerate(maListe):
    print(value)</code></pre>
  <pre><code class="language-python">for i, value in enumerate(maListe):
    print("indice {}, valeur {}".format(i,value))</code></pre>



  <!-- ====== UTILISATION AVANCEE DES LISTES ===== -->

  <h4 id="py_liste_avance">Utilisation avancée des listes</h4>

  <h4>Affectation par valeurs, affectation par référence</h4>

  <p>Il existe principalement deux manières de copier des listes en Python avec des fonctionnalités différentes. L'affectation
  par référence pointe vers l'adresse d'une liste, et donc tout changement opéré sur la copie affecte l'original. En revanche,
  l'affectation par valeurs copie les éléments d'une liste un à un, et donc tout changement opéré sur la copie n'a aucun effet
  sur l'original. L'affectation par référence consomme moins d'espace mémoire.</p>

  <pre><code class="language-python">maListe = ["a", "b", "c"]
copie_liste = maListe

copie_liste[1] = "hello"
print(maListe)</code></pre>

  <p>Le code ci-dessus qui copie la liste par référence affiche ['a', 'hello', 'c'], alors que le code ci-dessous qui
  copie la liste par valeurs affiche</p>

  <pre><code class="language-python">maListe = ["a", "b", "c"]
copie_liste = list(maListe)

copie_liste[1] = "hello"
print(maListe)</code></pre>

  <p>Ce dernier code est équivalent à :</p>

  <pre><code class="language-python">maListe = ["a", "b", "c"]
copie_liste = list()
for i in range(3):
    copie_liste[i] = maListe[i]

copie_liste[1] = "hello"
print(maListe)</code></pre>

  <h4>Les fonctions callback avec map</h4>

  <pre><code class="language-python">def carre(x):
    return x ** 2

maListe = [1, 2, 3, 4, 5]
print map(carre, maListe) # Affiche [1, 4, 9, 16, 25]</code></pre>

  <h4>Les fonction callback avec filter</h4>

  <pre><code class="language-python">def pair(x):
    return not bool(x % 2)

maListe = [1, 2, 3, 4, 5]
print filter(pair, maListe) # Affiche [2, 4]</code></pre>

  <h4>Les compréhensions de liste</h4>

  <p>Les compréhensions de liste permettent de modifier les éléments d'une liste selon une structure très particulière.
    Elles produisent des résultats semblables à ceux produits par le package Numpy mais dans le cas plus général que celui
    des nombres. Par exemple pour mettre les éléments au carré, on procède ainsi :</p>
  <pre><code class="language-python">nouvelleListe = [elt**2 for elt in maListe]</code></pre>

  <p>Les compréhensions de liste permettent également de filtrer les éléments d'une liste suivant une condition particulière. Par exemple pour rechercher les éléments pairs, on procède ainsi :</p>
  <pre><code class="language-python">nouvelleListe = [elt for elt in maListe if elt%2==0]</code></pre>

<p>Les compréhensions de liste sont préférables aux fonctions map et filter.</p>

  <h4>Conversion d'une liste en chaîne</h4>

  <p>La conversion d'une liste en chaîne et inversement est nécessaire pour effectuer certains traitements sur lse chaînes
    de caractères. En effet, les chaînes sont censées être de taille fixe et il n'existe pas de type Stringbuffer comme em Java par exemple.</p>

  <p>Pour convertir maListe en maChaine avec le séparateur "," :</p>

  <pre><code class="language-python">maListe = ["h", "e", "l", "l", "o"]
maChaine = "-".join(maListe)
print(maChaine # affiche h-e-l-l-o</code></pre>

  <p>Pour convertir maListe en maChaine sans séparateur :</p>

  <pre><code class="language-python">maListe = ["h", "e", "l", "l", "o"]
maChaine = "".join(maListe)
print(maChaine # affiche hello</code></pre>

  <p>Pour convertir maChaine en maListe :</p>

  <pre><code class="language-python">maListe = maChaine.split(", ")</code></pre>

  <p>L'utilisation de join avec des listes de compréhension permet l'affichage de plusieurs lignes dans une même chaìne.</p>

  <pre><code class="language-python">annuaire = [
  (1, "antoine"),
  (5, "celine"),
  (6, "herve")
]

print("\n".join(["%d pour %s" % (nbre, nom) for nbre, nom in annuaire]))</code></pre>

  <p>ce qui affiche : </p>
  <pre><code class="language-svg">1 pour antoine
5 pour celine
6 pour herve</code></pre>




<!-- ===== LES DICTIONNAIRES ===== -->

<h3 id="py_dictionnaire">Les dictionnaires</h3>

  <p>Les dictionnaires sont constitués d'un ensemble de clés-valeurs, dans lequel il n'y a aucun ordre.
  Leur structure est similaire à celle d'un format JSON.</p>
  <pre><code class="language-python">dico ={
  "nom" : "Antoine",
  "prenom" : "Hervé"
}</code></pre>

  <p>Pour créer un dictionnaire vide :</p>
  <pre><code class="language-python">dico = dict()</code></pre>

  <p>ou également :</p>
  <pre><code class="language-python">dico = {}</code></pre>

  <p>Pour accéder à un élément du dictionnaire, il ne faut plus appeler son
    indice qui n'existe pas mais appeler la clé de la façon suivante :</p>

  <pre><code class="language-python">dico["nom"]</code></pre>

  <p>Pour ajouter un élément à la fin d'un dictionnaire, il suffit de créer cet élément :</p>
  <pre><code class="language-python">dico["lieuNaissance"] = "Lausanne";</code></pre>

  <h4>Parcourir un dictionnaire</h4>

  <pre><code class="language-python">for cle in dico.keys():
  print(cle)

for valeur in dico.values():
  print(valeur)

for cle, valeur in dico.items():
    print(f"Clé {cle} - Valeur {valeur}")</code></pre>

  <h4>Propriétés d'un dictionnaire</h4>

  <table>
    <tr><th>Propriétés</th><th>Codes</th></tr>
    <tr><td>taille</td><td><pre>len(dico)</pre></td></tr>
    <tr><td>affichage de tous les éléments sans format spécifique</td><td><pre>dico.items()</pre></td></tr>
    <tr><td>modifier l'élément de clé key</td><td><pre>dico["key"] = "value"</pre></td></tr>
    <tr><td>ajout d'un élément</td><td><pre>dico["key"] = "value"</pre></td></tr>
    <tr><td>suppression d'un élément défini par sa clé sans renvoi de sa valeur</td><td><pre>del dico["key"]</pre></td></tr>
    <tr><td>suppression d'un élément défini par sa clé et renvoi de sa valeur</td><td><pre>dico.pop("key")</pre></td></tr>
  </table>

  <h4>Définir les attributs d'un objet à partir d'un dictionnaire</h4>

  <p>Dans le constructeur d'une classe, pour instancier des objets dont les attributs portent le même nom que les clés d'un dictionnaire :</p>

  <pre><code class="language-python">def __init__(self, dico):
  for attr_name, attr_value in dico.items():
    setattr(self, attr_name, attr_value)</code></pre>

<h4>Conversion d'un dictionnaire en chaìne</h4>

  <p>De la même façon qu'avec des listes, on peut transformer un
    dictionnaire en chaìne en spécifiant un séparateur de valeurs
    (attention, seules les clés seront utilisées) :</p>

  <pre><code class="language-python">dico = {'name' : 'daniel', 'age'
    : '30'}
chaine = '#'.join(dico)</code></pre>

  <p>On obtiendra alors comme résultat : name#age</p>

  <h4>Utiliser la méthode setdefault pour afficher la valeur d'une clé</h4>

  <p>La méthode setdefault permet d'éviter de lever une exception dans le
    cas où la clé consultée n'existe pas dans le dictionnaire. Dans ce
    cas la clé est créée et l'élément en 2ème position est la valeur
    attribuée à cette clé. Cette méthode est donc à privilégier
    systématiquement lors de l'appel d'une valeur. Dans l'exemple ci-dessous
    le code affiche Ford lorsqu'on demande la marque et affiche blanche
    lorsqu'on demande la couleur qui n'existait pas auparavant. Notons que le
    dictionnaire a bien été complété d'un élément.</p>

  <pre><code class="language-python">dico = {
  'marque': 'Ford',
  'modele': 'Fiesta'
}

print(dico.setdefault('marque', 'Citroen')
print(dico.setdefault('couleur', 'blanche')</code></pre>



  <!-- ===== LES FONCTIONS ===== -->

  <h3 id="py_fonction"> Les fonctions </h3>

  <p>La déclaration d'une fonction se réalise de la manière suivante :</p>
  <pre><code class="language-python">def nomFonction(parametre) :
  instructions
  return valeur</code></pre>

  <fieldset><legend>ATTENTION </legend>
    <p>En Python le type de retour de la fonction et le type des arguments ne sont pas spécifiés lors de la déclaration. Il est donc impossible de surcharger une fonction en Python.</p>
  </fieldset>

  <p>L'appel de la fonction se fait de la façon suivante :</p>
  <pre><code class="language-python">int valeur = nomFonction(12)</code></pre>

  <p>Lorsqu'il n'y a pas de valeur de retour, on parle de procédure :</p>
  <pre><code class="language-python">def nomProcedure(parametre) :
    instructions</code></pre>

  <p>L'appel de la procédure se fait de la façon suivante :</p>
  <pre><code class="language-python">nomProcedure(12);</code></pre>

  <p>Pour une fonction comme pour une procédure, on peut définir une valeur de paramètre par défaut si celle-ci n'est pas spécifiée, de la manière suivante :</p>
  <pre><code class="language-python">def nomFonction(parametre1, parametre2=43) :
  instructions
    return valeur</code></pre>

  <p>Bien que la valeur 43 soit attribuée par défaut au parametre2, celui-ci peut prendre n'importe quelle valeur qui lui soit attribuée.</p>

  <p>En Python, pour créer des fonctions attendant un nombre inconnu de paramètres, on utilise la syntaxe</p> <pre>def maFonction(*monTableau)</pre> <p>où <em>monTableau</em> est un tableau de parametres.</p>

   <h4>Documenter une fonction</h4>

    <p>En Python, l'ajout d'une <em>docstring</em> se fait sous le nom de la fonction, avec une indentation et 3 guillements. Elle peut s'étendre sur plusieurs lignes.</p>
    <pre><code class="language-python">def maFonction(parametre) :
  """documentation
  de maFonction"""
  instructions
  return</code></pre>

    <p>On appelle la documentation en utilisant l'instruction <strong>help(maFonction)</strong></p>

    <h4>Fonction anonyme</h4>

    <p>En Python, la fonction anonyme est appelée fonction <em>lambda</em>, mais le principe reste identique. On remplace dans ce cas le mot-clé <strong>def</strong> par <strong>lambda</strong> et on ne spécifie aucun nom pour la fonction créée.</p>
    <pre><code class="language-python">int maVariable = lambda x :
  2*x

   print(maVariable(3))</code></pre>

    <pre><code class="language-python">str maVariable = lambda parametre :
  "Bonjour ",parametre

   print(maVariable("Hervé"))</code></pre>

  <p>On remarque qu'une fonction lambda utilise une construction particuliére et transforme la variable <em>maVariable</em> en fonction.</p>

    <h4>Fonctions prédéfinies </h4>

    <table>
      <tr><th>Fonctions</th><th>Actions</th></tr>
      <tr><td>Math.min(2, 4)</td><td>donne le minimum des paramètres passés en arguments</td></tr>
      <tr><td>Math.random</td><td>génère un nombre aléatoire entre 0 et 1</td></tr>
    </table>

  <h4>Utilisation de la fonction callback en Python</h4>

  <p>Il s'agit d'une fonction qui sert de paramètre à une autre fonction.</p>

  <pre><code class="language-python">def maFonction(x):
  instruction

def autreFonction(maFonction, val):
  return maFonction(val)</code></pre>




  <!-- ===== LES DOCTRINGS ===== -->

  <h3 id="py_doc">Les docstrings</h3>

  <p>Les conventions pour la doctring sont les suivantes :</p>
<pre><code class="language-svg">def ma_fonction(nom):
  """description generale

  Parameters :
  nom (str): description de nom

  Returns :
  nouveau_nom (str): description de nouveau_nom


  description en details"""</code></pre>

  <p>Pour appeler une doctring, il faut taper dans le shell :</p>
<pre><code class="language-svg">help(ma_fonction)</code></pre>



  <!-- ===== LES EXCEPTIONS ===== -->

  <h3 id="py_exception">La gestion des exceptions</h3>

  <p>Elles se construisent suivant les cas de différentes manières :</p>
  <pre><code class="language-python">try: # cas général
  instruction à tester
except:
  instruction en cas d'erreur
finally:
  instruction dans tous les cas

try: # variable non définie
  instruction à tester
except NameError as e:
  instruction en cas d'erreur

try: # le type de la variable est incompatible avec l'instruction
  instruction à tester
except TypeError as e:
  instruction en cas d'erreur

try: # division par 0
  instruction à tester
except ZeroDivisionError:
  instruction en cas d'erreur</code></pre>

  <p>Pour aller plus loin, la documentation Python officielle <a href="https://docs.python.org/3.5/library/index.html"><em>The Python Standard Library</em></a>.</p>



  <!-- ===== LES OBJETS EN PYTHON ===== -->

  <h3 id="py_objet"> La programmation objet</h3>

    <p>La création d'une classe en Python :</p>
    <pre><code class="language-python">class MaClasse:
  MON_ATTRIBUT  # attribut de classe

  __init__(self, nom, prenom):
    self.nom = nom
    self.prenom = prenom

  def uneMethode(parametre):
    instructions

}</code></pre>

  <p>On remarque que la signature d'une méthode ne comprend pas le type renvoyé par la méthode. Notons également que le
  constructeur d'une classe en Python est __init__(self). Le mot-clé self doit obligatoirement apparaître parmi les paramètres
  du constructeur contrairement à d'autres langages. En revanche, il n'est pas nécessaire de définir les attributs, comme nom
    et prenom dans l'exemple ci-dessus, avant la définition des méthodes. Seuls les attributs de classe s'écrivent en majuscule
    avec éventuellement des underscores. Ils n'utilisent pas de mot-clé spécifique. En Python les attributs de classe sont en fait
  vus comme des constantes propres à une classe.</p>

  <p>Les méthodes de classes prennent toujours en paramètre le mot-clé self.</p>

  <p>L'instanciation d'un objet se fait sans recours au mot-clé traditionnel new des autres langages :</p>
  <pre><code class="language-python">monObjet = MaClasse("Charles", "Hervé")</code></pre>

  <p>On peut accéder aux attributs de classe à partir d'un objet mais également directement à partir de la classe de la façon suivante :</p>
  <pre><code class="language-python">MaClasse.MON_ATTRIBUT</code></pre>

  <p>Par défaut toutes les méthodes sont publiques. Pour les rendre protégées il faut ajouter un underscore devant la méthode
  et pour les rendre privées il faut rajouter deux underscores</p>

  <pre><code class="language-python">def _maMethodeProtegee:
def __maMethodePrivee</code></pre>





  <!-- Input/Ouput ------------------------------------------------------>

  <h3 id="py_in_out">Input / Output</h3>

  <p>Pour intégrer un fichier physique dans un code, il faut créer un objet
    à l'aide de l'instruction open(). On peut employer with open() au lieu de
    open() afin de fermer cet objet à la fin de son utilisation. On évite
    ainsi d'utiliser l'instruction close().</p>

  <p>Il est souvent nécessaire de gérer des exceptions du type OSError.</p>

  <p>Le mode d'ouverture d'un fichier peut prendre les paramètres suivants :</p>

  <table>
    <tr><th>objectif</th><th>code</th></tr>
    <tr><td>lecture (read)</td><td>r</td></tr>
    <tr><td>lecture/écriture</td><td>r+</td></tr>
    <tr><td>écriture (write)</td><td>w</td></tr>
    <tr><td>écriture/lecture</td><td>w+</td></tr>
    <tr><td>ajout en fin de fichier (append)</td><td>a</td></tr>
    <tr><td>ajout en fin de fichier et lecture</td><td>a+</td></tr>
    <tr><td>lecture au format binaire</td><td>rb</td></tr>
    <tr><td>lecture/écriture au format binaire</td><td>rb+</td></tr>
    <tr><td>écriture au format binaire </td><td>wb</td></tr>
    <tr><td>écriture/lecture au format binaire </td><td>wb+</td></tr>
    <tr><td>ajout en fin de fichier au format binaire</td><td>ab</td></tr>
    <tr><td>ajout en fin de fichier et lecture en binaire</td><td>ab+
    </td></tr>
  </table>

<p>ATTENTION, chaque mode possède ses particularités : </p>
  <ul>
    <li>w EFFACE SYSTEMATIQUEMENT LE CONTENU DU FICHIER AU
      MOMENT DU CHARGEMENT DU FICHIER. w est donc réservé à l'ouverture d'un
    fichier vide ou à la remise à zéro d'un fichier.</li>
    <li>r+ et w+ fournissent les mêmes fonctionnalités mais w+ commence par effacer
      le contenu du fichier alors que r+ conserve le contenu du fichier. w+ est
      donc réservé à l'ouverture d'un fichier vide ou à la remise à zéro d'un
      fichier. Dans le mode r+, le pointeur se place au début du fichier au
      démarrage et l'écriture écrasera donc le début du fichier si un emplacement
      spécifique n'est pas précisé pour le pointeur.</li>
    <li>a et a+ ne permettent pas de rajouter un élément dans un fichier JSON car
    l'ajout en dernière ligne ne tient pas compte de la structure du document.
    Il faut donc dans ce cas procéder autrement en intégrant l'ajout à l'ensemble
    des données.</li>
  </ul>

  <p>A l'ouverture du fichier le pointeur se trouve au début du fichier.
    Une fois les instructions effectuées, il se trouve à la fin du fichier.
    Toute instruction supplémentaire partira au niveau courant du pointeur,
    donc ici la fin du fichier. Ainsi, si on demande l'affichage du fichier à
    ce moment-là, cet affichage sera vide alors qu'il ne l'est pas forcément.
  </p>

  <p>Pour lire le contenu d'un fichier ou écrire à un emplacement qui ne
    correspond pas à celui du pointeur, il faut repositionner ce pointeur grâce à
    l'instruction seek(position, from). Le paramètre position compte le
    nombre de bytes en partant du paramètre from. Le paramètre from vaut
    0 si on part du début, 1 si on part de la position courante et 2 si on
    part de la fin du texte. Attention, il est possible de placer le pointeur
    devant l'emplacement précis d'un byte, mais il n'est pas possible de le
    placer devant l'emplacement précis d'un caractère car celui-ci peut être
    représenté par plusieurs bytes. Le code suivant place le pointeur à la fin du
    7ème  byte (caractère d'indice 7 dans le cas d'un texte) après le point de
    départ, puis remplace la valeur à cet emplacement par 'x' :</p>

  <pre><code class="language-python">with open('page.txt', 'r+) as f:
    f.seek(0, 7)
    f.write('x')</code></pre>

  <p>Considérons le fichier suivant appelé page.txt :</p>
  <pre><code class="language-svg">voici ma 1ère ligne
voici ma 2ème ligne</code></pre>

  <p>Le mode w considère toujours que le fichier ouvert est nouveau et
    EFFACE AUTOMATIQUEMENT SON CONTENU A L'OUVERTURE.</p>
<pre><code class="language-python">with open('page.txt', 'w') as f:
    f.write('texte à rajouter')</code></pre>

  <p>Attention, pour écrire un terme qui n'est pas un string dans un fichier
    texte, il est nécessaire de le caster en string auparavant. De même,
    tout élément lu d'un fichier texte est de type string même si il s'agit
    d'un nombre. En d'autres termes, write() prend un string comme paramètre
    et read() renvoie un string.</p>

  <p>readline() renvoie un string et n'affiche que la ligne où se trouve le
    pointeur, dans l'exemple ci-dessous uniquement la 1ère ligne :</p>
  <pre><code class="language-python">with open('page.txt', 'r') as f:
    ma_chaine = f.readline()
    print(ma_chaine)</code></pre>

  <p>read() renvoie un string et affiche tout le texte :</p>
  <pre><code class="language-python">with open('page.txt', 'r') as f:
    ma_chaine = f.read()
    print(ma_chaine)</code></pre>

  <p>A noter que f.read(11) ne valire que les 11 premiers bytes à partir de
    l'emplacement du pointeur.</p>

  <p>readlines() renvoie une liste et affiche tout le texte dans cette liste
    en utilisant des \n pour chaque saut de ligne :</p>
  <pre><code class="language-python">with open('page.txt', 'r') as f:
    ma_liste = f.readlines()
    print(ma_liste)</code></pre>

  <p>Le mode a permet de rajouter un élément en fin de fichier :</p>
  <pre><code class="language-python">with open('page.txt', 'a') as f:
    f.write('voici ma 3ème ligne')</code></pre>

<p>Attention, le mode a+ permet de rajouter un élément au fichier et de lire
  son contenu. Toutefois, le code suivant n'affiche rien car après avoir
  rajouté du texte au fichier, le pointeur se situe en fin de fichier et
  affiche donc la fin du fichier, i.e. rien :</p>

  <pre><code class="language-python">with open('page.txt', 'a+') as f:
    f.write('voici ma 3ème ligne')
    ma_liste = f.read()
    print(ma_liste)</code></pre>

<p>ce qu'on peut corriger par le code suivant :</p>

  <pre><code class="language-python">with open('page.txt', 'a+') as f:
    f.write('voici ma 3ème ligne')
    f.seek(0, 0)
    ma_liste = f.read()
    print(ma_liste)</code></pre>




  <h4>Décodage des bytes en string</h4>

  <p>Pour décoder des bytes en string unicode utf8, on utilise :</p>
  <pre><code class="language-python">bb = b'\xc2\xa9 abc'
u = bb.decode('utf-8)</code></pre>

  <p>Pour encoder un string utf8 en bytes, on utilise :</p>
  <pre><code class="language-python">chaine = 'hello'
bb = chaine.encode('utf-8)</code></pre>




<h4>Parcourir un répertoire</h4>

  <p>Afin d'afficher tous les éléments se trouvant dans un dossier de l'ordinateur grâce à Python :</p>

  <pre><code class="language-python">from os import listdir
for item in listdir('/home/user/monDossier'):
  print(item)</code></pre>







  <h4>Parser du JSON / Sérialiser en JSON</h4>

  <p>Parser consiste à analyser une suite de données afin d'en
    récupérer la structure et de l'incorporer dans un objet structuré.
    Transformer un fichier JSON en dictionnaire (objet structuré Python) est un
    exemple de parsing. Pour cela on utilise les étapes suivantes : ouvrir un fichier JSON,
  récupérer le contenu sous forme de string JSON, transformer ce contenu en dictionnaire
  Python.</p>

  <p>Sérialiser consiste à transformer un objet en une structure lisible et
    capable d'être stockée comme une série de bytes. Par exemple, convertir un
    dictionnaire en un fichier au format JSON. Pour cela on utilise les étapes
  suivantes : transformer un dictionnaire Python en string, </p>

  <p>Le Marshalling consiste à transformer une structure de données en un
    format différent.</p>

  <p>Voici un tableau de conversion des objets Python en équivalents JSON :</p>
  <table>
    <tr><th>Python</th><th>JSON</th></tr>
    <tr><td>dict</td><td>Object</td></tr>
    <tr><td>list, tuple</td><td>Array</td></tr>
    <tr><td>str</td><td>String</td></tr>
    <tr><td>int, float</td><td>Number</td></tr>
    <tr><td>True, False</td><td>true, false</td></tr>
    <tr><td>None</td><td>Null</td></tr>
  </table>

  <p>JSON ne se trouve pas nativement dans l'environnement de travail. Il est donc nécessaire de l'importer.</p>
  <pre><code class="language-python">import json</code></pre>

  <p>JSON JavaScript Object Notation est un format de stockage de données
    (littéralement du texte écrit en notation objet). Le format JSON est
    particulièrement utilisé dans le cadre d'échanges de données, et peut être
    interpété par de nombreux langages, facilitant ainsi l'interopérabilité.</p>

  <p>Les données seront stockées suivant le format clé-valeur d'un
    dictionnaire. Mais attention, un dictionnaire accepte indifféremment les
    ' ou les " alors que le format JSON n'accepte que les ". On
    peut par exemple avoir la structure suivante :</p>
  <pre><code class="language-svg">{
    "collège_St_André":
        [
            {
                "nom": "Fremon",
                "prenom": "Antoine",
                "pseudo": "toto",
                "moyennes":
                    {
                        "6ème": 14,
                        "5ème": 14,
                        "4ème": 13,
                        "3ème": 11.5
                    }
            },
            {
                "nom": "Sabert",
                "prenom": "CLementine",
                "pseudo": "clea"
                "moyennes":
                    {
                        "6ème": 12,
                        "5ème": 13,
                        "4ème": 12,
                        "3ème": 11
                    }
            }
        ],
        #
        "collège_bernard":
        [
            {
                "nom": "Carmeni",
                "prenom": "Louis",
                "pseudo": "lolo",
                "moyennes":
                    {
                        "6ème": 19,
                        "5ème": 16,
                        "4ème": 16,
                        "3ème": 14
                    }
            },
            {
                "nom": "Florimar",
                "prenom": "Capucine",
                "pseudo": "cap"
                "moyennes":
                    {
                        "6ème": 18,
                        "5ème": 18,
                        "4ème": 17,
                        "3ème": 18
                    }
            }
        ]
}</code></pre>

  <p>Pour utiliser ce fichier JSON, il faut d'abord l'ouvrir sous forme de
    string puis le parser sous forme de dictionnaire afin d'en récupérer la
    structure :</p>
  <pre><code class="language-python">with open('page.json', 'r') as f:
    # transforming page.json into a JSON string
    chaine = f.read()
    # parsing the JSON string into a dictionary
    dico = json.loads(chaine)
    print(dico['ma_cle'])</code></pre>

  <p>Pour écrire sur un fichier JSON (sérialiser un dictionnaire pour le
    transformer en format JSON), on ne peut pas se contenter de rajouter des éléments
    à la fin, car ces éléments doivent s'intégrer à une structure de données. Il
  faut reprendre ce qui reste inchangé, intégrer les nouvelles données et transformer
  tout l'ensemble. Cela est coûteux en espace mémoire et temps de travail.</p>

  <pre><code class="language-python">with open('page.json', 'r+') as f:
    # transforming page.json into JSON string
    js = f.read()
    # transforming JSON string into dictionary using the initial JSON structure
    dico = json.loads(js)
    # adding a key/value
    dico.update({"lundi": "Monday"}) # or dico["lundi"] = "Monday"
    # setting the pointer on 1st position
    f.seek(0,0)
    # transforming dictionary into JSON string and writing on page.json
    f.write(json.dumps(dico, indent=4)) # JSON string</code></pre>

  <p>Il est possible de sérialiser suivant un format plus facilement lisible
  :</p>
  <pre><code class="language-python">json.dumps(dico, indent=4, separators=(",", ":"))</code></pre>

  <p>En résumé, json.loads(json_str) transforme un string JSON en dictionnaire Python, et
  json.dumps(object) transforme un dictionnaire Python en string JSON.</p>

<p>Le module pickle permet la sérialisation/parsing d'objets Python
  complexes, mais il est spécifique à Python et ne peut donc pas servir pour
  communiquer avec des applications écrites dans un autre langage.</p>


<!-----------------------
ENVIRONNEMENTS DE TRAVAIL
------------------------>

  <h3 id="py_environnement">Les environnements de travail</h3>



  <!-- ===== CHANGER LES VERSIONS DE PYTHON ============================== -->

  <h4 id="py_version">Gérer les versions de Python avec pyenv</h4>

  <p>Pour connaître la version active de Python :</p>
  <pre><code class="language-svg">python --version</code></pre>

  <p>Pour connaître toutes les versions disponibles au téléchargement de Python 3.6 à 3.8 :</p>
  <pre><code class="language-svg">pyenv install --list | grep " 3\.[678]"</code></pre>

  <p> Toutes les versions s'installent dans un fichier <em>.pyenv/versions/</em>, qui vient s'insérer dans le PATH au coeur du
    système, et non pas directement dans un  environnement de développement. Ainsi, un environnement peut utiliser une
    version particulière de Python en pointant vers l'adresse de stockage de la version, sans qu'elle soit incorporée à
    cet environnement. Pour installer la version 3.7.2 en particulier :</p>
  <pre><code class="language-svg">pyenv install -v 3.7.2</code></pre>

  <p>Pour supprimer la version 2.7.15 de l'ordinateur :</p>
  <pre><code class="language-svg">pyenv uninstall 2.7.15</code></pre>
  <p>Attention de travailler avec une version 3 de Python et de ne pas supprimer la version 2 système de Python livrée
    d'usine et qui peut servir au fonctionnement de l'ordinateur. Ce n'est plus le cas pour Ubuntu 20.04 LTS qui fonctionne
    avec Python 3.8</p>

  <p>Il est important de bien connaître la version de Python utilisée avant de procéder à tout changement dans un
    environnement de développement, car chaque version accepte des dépendances différentes.</p>

  <p>Pour connaître toutes les versions disponibles sur l'ordinateur (la version active est précédée d'une *) :</p>
  <pre><code class="language-svg>">pyenv versions</code></pre>

  <p>Pour connaître l'adresse de la version de Python utilisée :</p>
  <pre><code class="language-svg">which python # ou encore
pyenv which python</code></pre>

  <p>Pour changer la version de Python en local dans l'environnement de développement :</p>
  <pre><code class="language-svg">pyenv local 3.7.1</code></pre>

  <p>Pour changer la version de Python pour tout l'ordinateur :</p>
  <pre><code class="language-svg">pyenv global 2.7.15</code></pre>

  <p>Pour revenir à la version système :</p>
  <pre><code class="language-svg">pyenv global system</code></pre>



  <h4>Particularité de l'utilisation de Anaconda</h4>

  <p>Pour télécharger l'environnement de travail Anaconda, il faut d'abord télécharger Anaconda pour Linux, vérifier le sha avec la commande :</p>
  <pre><code class="language-svg">sha256sum [nom_fichier_telecharge]</code></pre>

  <p>puis exécuter le fichier d'installation :</p>
  <pre><code class="language-svg">bash Anaconda-[version]-Linux-x86_64.sh</code></pre>

  <p>Finalement, il est possible de tester l'installation en utilisant :</p>
  <pre><code class="language-svg">conda list</code></pre>

  <p>Une fois qu'on a installé Anaconda, l'exécution se fait grâce à l'instruction :</p>
  <pre><code class="language-svg">anaconda-navigator</code></pre>

  <p>Pour mettre à jour Anaconda :</p>
  <pre><code class="language-svg">conda update conda</code></pre>

  <p>Pour connaître l'emplacement de conda :</p>
  <pre><code class="language-svg">which conda</code></pre>


  <!-- CREER DES ENVIRONNEMENTS DE TRAVAIL --------------------------->

  <h3 id="py_env">Créer des environnements de développement avec venv</h3>

  <p>Il est nécessaire de travailler dans des environnements virtuels pour isoler les dépendances de chaque projet Python.
    Pour cela, on utilise le module venv compris dans la librairie standard de Python3. Il est également possible d'utiliser
    virtualenv à la place de venv, mais ce dernier est déjà compris dans les versions de Python supérieures à 3.5 et ne
    nécessite donc pas d'installer virtualenv comme une dépendance.</p>

  <p>Au terminal, on crée tout d'abord le dossier qui va contenir mes environnements virtuels, puis on se place dedans :</p>

  <pre><code class="language-svg">mkdir environnements
cd environnements</code></pre>

  <p>On crée maintenant un nouvel environnement au sein du dossier environnements :</p>

  <pre><code class="language-svg">python3 -m venv mon_env</code></pre>

  <p>Pour visualier la structure de mon_env il suffit de taper tree dans le dossier courant.</p>

  <img src="venv.png">

  <p>bin contient les fichiers qui interagissent avec l'environnement virtuel, include contient les en-têtes C qui compilent
    les packages Python, lib contient une copie de la version Python avec un dossier de packages dans lequel sont installées
    toutes les dépendances.</p>

  <p>Il est maintenant nécessaire d'activer l'environnement virtuel comme environnement de travail. Pour cela, il faut se
    placer dans le dossier environnements et taper au Terminal :</p>

  <pre><code class="language-svg">source mon_env/bin/activate</code></pre>

  <p>A partir de maintenant, les commandes saisies ont une action dans l'environnement. On remarque que l'environnement
    est actif, car devant le prompt du Terminal apparaît (mon_env)$.</p>

  <p>Pour désactiver cet environnemnt virtuel, il suffit de taper :</p>

  <pre><code class="language-svg">deactivate</code></pre>

  <p>Pour installer un module dans l'environnement, il faut d'abord se rendre dans l'environnement puis :</p>
  <pre><code class="language-svg">cd mon_env
pip3 install nom_package</code></pre>

  <p>Pour désinstaller un module dans l'environnement :</p>
  <pre>pip3 uninstall nom_package</pre>

  <p>Pour voir la liste de tous les modules installés :</p>
  <pre><code class="language-svg">pip3 freeze</code></pre>

  <p>Pour utiliser une version particulière de Python dans l'environnement, il faut d'abord installer cette version sur
    l'ordinateur, puis se rendre dans l'environnement et définir cette version comme la version locale :</p>
  <pre><code class="language-svg">pyenv install 3.8.0
cd mon_env
pyenv local 3.8.0</code></pre>



  <!-- ===== UTILISATION DE PYCHARM DANS UN ENVIRONNEMENT ===== -->

  <h3 id="py_pycharm">Utilisation de PyCharm dans un environnement particulier</h3>

  <p>PyCharm crée automatiquement un dossier PyCharmProjects dans lequel il va ranger les différents projets. On peut
    alors choisir l'interpréteur parmi ceux proposés, et en fonction de ce qui a été installé (conda, virtualenv, une version
    particulière de Python ...). Pour cela, après avoir ouvert PyCharm, sélectionné le projet, puis File -> Settings ->
    Project Interpreter.</p>

  <p>On peut également utiliser un environnement lié à un projet déjà existant. Pour cela, on commence par créer un dossier
    dans lequel on crée l'environnement de développement avec venv, puis on ouvre PyCharm, on ouvre le projet existant,
    File -> Settings -> Project Interpreter. PyCharm devrait avoir reconnu l'environnement de travail et pointer directement
    vers la bonne version de Python, avoir les bons packages déjà installés. Si ces packages font défaut lors de l'exécution,
    l'erreur liée au package donne lieu à un signal rouge et un menu qui permet de confirmer l'installation du package.</p>












  <!-------------------
  INTERFACES GRAPHIQUES
  -------------------->

  <h3 id="#py_interface">Les interfaces graphiques</h3>


  <!------ ARGPARSE ------->

  <h4 id="py_argparse">L'interface en ligne de commande avec argparse</h4>

  <p>Le module argparse permet de créer une Command Line Interface. Par exemple :</p>
  <pre><code class="language-python">mp = argparse.ArgumentParser(prog='nom_programme', description="A description that shows up")
mp.add_argument("nom", type=str, help="requires a string")
mp.add_argument("--collect", action='store_true', help="description of the --collect option")
args = mp.parse_args()
item = args.nom

if args.collect:
    print(item)</code></pre>




  <!-----TKINTER------>

  <h4 id="py_tkinter">L'interface graphique avec Tkinter</h4>

  <p>L'interface graphique Tkinter est fonctionnelle mais relativement sommaire. Il est possible d'intégrer du code java
  pour améliorer l'interface en utilisant le module Jython. Toutefois, le code suivant permet d'obtenir une fenetre pourvue des
  principales fonctionnalités :</p>

  <pre><code class="language-python"># creates a window
fenetre = Tk()
fenetre.title("Bumber")
fenetre.geometry("800x800")
fenetre.configure(bg="#83C7BC")
interfaceAccueil = InterfaceAccueil(fenetre)
interfaceAccueil.mainloop()

couleurFond = "#83C7BC"

class InterfaceAccueil(Frame):
    """
    defining a graphical interface class which asks the user the kind of
    action he wants to do : consult, insert, modify, delete
    """

    def __init__(self, fenetre, **kwargs):

        # creating the structure of the window
        Frame.__init__(self, fenetre, **kwargs)
        frame = Frame(fenetre, bg=couleurFond)
        frameHaut = Frame(frame, bg=couleurFond)
        frameMilieu = Frame(frame, bg=couleurFond)
        frameBas = Frame(frame, bg=couleurFond)
        frame.pack(side=TOP)
        frameHaut.pack(side=TOP)
        frameMilieu.pack()
        frameBas.pack(side=BOTTOM)
        self.pack()

        # creating a widget message at the top of the page
        self.messageAnnonce = Label(frameHaut, text="Select a category below :\n", bg=couleurFond)
        self.messageAnnonce.pack()

        # creating a widget radio button
        self.choixCategorie = StringVar()
        self.boutonRadioService = Radiobutton(frameHaut, text="Service", bg=couleurFond,
                                    variable=self.choixCategorie, value="service")
        self.boutonRadioAdministration = Radiobutton(frameHaut, text="Administration",
                                                     bg=couleurFond, variable=self.choixCategorie,
                                                     value="administration")
        self.boutonRadioService.pack(side=RIGHT)
        self.boutonRadioAdministration.pack(side=RIGHT)

        # creating widgets button Consult, Insert
        self.messageVide = Label(frameMilieu, text="", bg=couleurFond)
        self.messageVide.pack(side=TOP)
        self.boutonConsult = Button(frameMilieu, text="Consult", fg="blue", bg=couleurFond,
                                     command=self.cliquerConsult)
        self.boutonInsert = Button(frameMilieu, text="Insert", fg="black", bg=couleurFond,
                                    command=self.cliquerInsert)
        self.boutonConsult.pack(side=RIGHT)
        self.boutonInsert.pack(side=RIGHT)

        # creating a message answering the request
        self.messageReponse = Label(frameBas, text="", bg=couleurFond)
        self.messageReponse.pack()

    def cliquerConsult(self):
        self.messageReponse["text"] = self.choixCategorie.get()</code></pre>




  <!-- ===== PEP8 ===== -->

  <h3 id="py-pep">Respect du PEP8</h3>

  <p>Python Enhancement Proposal 8 requiert le respect des règles suivantes:</p>
  <ul>
    <li>une ligne doit contenir au maximum 80 caractères</li>
    <li>l'indentation doit contenir 4 espaces</li>
    <li>2 lignes vides au-dessus d'une classe</li>
    <li>les docstrings sont obligatoires pour les méthodes, les classes et les modules</li>
    <li>l'import d'un module ou d'un package doit se faire en début de code</li>
    <li>pas d'espace avant : mais un espace après</li>
    <li>un espace autour d'un opérateur</li>
    <li>un espace autour d'un = pour assigner une valeur à une variable</li>
    <li>pas d'espace autour d'un = pour assigner une valeur par défaut à un paramètre</li>
    <li>une instruction par ligne</li>
    <li>les commentaires sont écrits en anglais</li>
    <li>les modules s'écrivent en minuscule, avec un underscore si besoin</li>
    <li>les packets s'écrivent en minuscule sans underscore</li>
    <li>les classes ont une 1ère lettre en minuscule et peuvent avoir d'autres lettres en majuscule</li>
    <li>les méthodes s'écrivent en minuscule, avec underscore si besoin</li>
    <li>les variables s'écrivent en minuscule, avec underscore si besoin</li>
    <li>les constantes s'écrivent en majuscules, avec underscore si besoin</li>
  </ul>

  <p>PyLint est un logiciel en ligne de commande permettant d'analyser le code en fonction des standards de PEP8.</p>

  <pre>pip install pylint
pylint fichier.py // lance l'analyse de fichier.py</pre>




  <!-- ==
  DJANGO
  ------>

  <h3 id="py_django">Le framework Django</h3>

  <p>Django est un framework opensource pour le développement Web Python. Il construit les applications suivant le
    design pattern MVT, inspiré de la structure classique MVC. Il contient déjà un gestionnaire de BDD sqlite, un serveur et un gestionnaire d'accès à la BDD
    en ligne de commande. Il n'est donc pas utile de recourir à l'utilisation de LAMP avec ce framework.</p>

    <p>Le design pattern MVT Model View Template est une architecture qui sépare les responsabilités de chaque groupe
        de code.</p>
    <ul>
        <li>Le Model interagit avec la base de données en utilisant un ORM Object Relational Mapping, qui transforme
    les résultats d'une requête SQL en objets Python et inversement. Par exemple l'instruction SQL suivante
    SELECT * FROM maTable se traduit de la façon suivante maTable.objects.all()</li>
        <li>Le Template est un fichier HTML qui peut recevoir les objets Python et qui est lié à une View. Il
        peut donc interpréter des variables et les afficher. </li>
        <li>La View reçoit une requête HTTP et interprète cette requête en HTML pour le navigateur.</li>
    </ul>

  <p>Les différentes étapes pour installer Django dans un environnement de projet sont les suivantes :</p>

  <pre><code class="language-svg">mkdir envDjango
cd envDjango
virtualenv env -p python3
. env/bin/activate
pip install django</code></pre>

  <p>On peut ensuite vérifier que la librairie Django est bien disponible en écrivant</p>

  <pre><code class="language-svg">python -m django --version</code></pre>

  <p>La création de la structure du projet se fait maintenant de la façon suivante :</p>

  <pre><code class="language-svg">django-admin startproject monProjet</code></pre>

  <p>Le dossier <strong>monProjet</strong> contient les éléments suivants</p>

  <pre><code class="language-svg">manage.py
monProjet/
  __init__.py
  settings.py
  urls.py
  wsgi.py</code></pre>

  <ul>
    <li>le fichier manage.py est un outil d'exécution des commandes utiles au projet, comme par exemple la
    création de tables dans la BDD</li>
    <li>le fichier settings.py contient la configuration globale du projet, comme par exemple les identifiants de
      connexion à la BDD, les chemins des différentes ressources, les différentes applications Django utilisées</li>
    <li>le fichier urls.py est le contrôleur des requêtes du projet</li>
    <li>le fichier wsgi.py permet la configuration du serveur</li>
  </ul>

  <p>On peut créer plusieurs applications au sein d'un même projet. Pour créer une application, on utilise</p>

  <pre><code class="language-svg">django-admin.py startapp monAppli</code></pre>

  <p>Le dossier <strong>monAppli</strong> contient les éléments suivants</p>

  <pre><code class="language-svg">__init__.py
models.py
views.py
tests.py</code></pre>

  <ul>
    <li>le fichier models.py accueille les modèles de l'application</li>
    <li>le fichier views.py accueille les controleurs de l'application</li>
    <li>le fichier tests.py accueille les tests unitaires et d'intégration de l'application</li>
  </ul>

  <p>Il faut préciser dans le fichier settings.yp la BDD que nous souhaitons utiliser.</p>
  <pre><code class="language-python">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'nomBdd',
    }
}</code></pre>

  <p>Il faut préciser dans le fichier settings.py que nous allons utiliser monApplication :</p>
  <pre><code class="language-python">INSTALLED_APPS={
  # code de fonctionnement déjà présent
  monAppli
}</code></pre>

    <p>Une URL est le premier point d'entrée d'une requête. Le fichier urls.py va donc se situer dans le dossier de configuration
        du projet django_project/django_project. Une bonne pratique consiste à créer un fichier urls.py par application et
        de l'importer dans les routes du projet.</p>

    <p>On commence par créer un dossier templates</p>

    <pre><code class="language-svg">mkdir monApp/templates</code></pre>

    <p>On crée ensuite un fichier urls.py dans monAppli</p>

    <pre><code class="language-svg">touch monAppli/urls.py</code></pre>

    <p>Il faut maintenant lier le contenu dans monProjet/urls.py</p>

    <pre><code class="language-svg">urlpatterns = [
    url('monAppli/', include('monAppli.urls')),
    url('admin/', admin.site.urls)
]</code></pre>

  <p>Il faut également créer les tables de la BDD, en se plaçant dans monProjet (afin que l'interpréteur trouve le
  fichier manage.py</p>
<pre><code class="language-svg">cd monProjet
python manage.py syncdb</code></pre>

  <p>Pour lancer le serveur, il faut également se placer dans monProjet et taper</p>
  <pre><code class="language-svg">python manage.py runserver</code></pre>





  <p>Il faut maintenant rajouter un gestionnaire de base de données. Choisissons par exemple Postgresql. Pour savoir si
    il est déjà installé, il suffit de taper psql, ce qui ouvre une console de communication avec le serveur. On peut alors
    revenir au terminal en tapant \q</p>

  <p>Pour installer Postgresql, il faut donner à un utilisateur le rôle de gestionnaire de la base de données. Il faut donc
  définir la variable d'environnement en ce sens. Nous choisissons le superuser comme gestionnaire.</p>

  <pre><code class="language-svg">sudo apt-get update
sudo apt-get install postgresql postgresql-contrib libpq-dev
sudo -u postgres createuser --superuser $USER
sudo -u postgres createdb $USER</code></pre>

  <p>Il faut créer un fichier conservant l'historique de travail dans le dossier home.</p>

  <pre><code class="language-svg">touch .psql_history
mv .psql_history ~/stephane</code></pre>

  <p>On peut maintenant se connecter au serveur en tapant psql, ce qui ouvre une console de commmunication avec
  Postgresql. Pour revenir au terminal, il faut taper \q afin de quitter la console.</p>



<h4>Comment redémarrer le framework ?</h4>

    <p>Pour redémarrer le framework, il faut activer l'environnement de travail (afin d'activer Django et les autres packages
    nécessaires au projet, puis démarrer le server lié au projet.</p>

    <pre><code class="lnaguage-svg">cd Documents/envDjango
. env/bin/activate
cd django_project
python manage.py runserver</code></pre>

    <p>Ensuite, il faut donner au navigateur (dans la barre de navigation) le chemin d'accès local vers les ressources du projet :</p>

    <pre><code class="language-svg">127.0.0.1:8000/monAppli/</code></pre>



  <!-------------------------------------
  EXECUTER DU BASH DANS DU CODE PYTHON
  --------------------------------------->
  <h3>Exécuter du bash dans du code Python</h3>

  <p>On peut exécuter un script Python qui interprète une ligne de commande à
    l'emplacement du dossier courant où se trouve le script, en utilisant le
    module subprocess. Par exemple pour afficher tous les dossiers et fichiers
    se trouvant dans le répertoire courant :</p>

  <pre><code class="language-python">import subprocess
subprocess.run('ls')</code></pre>

    <h3>Les graphes en Python</h3>

  <h4>Courbe 2d</h4>

    <p>Une courbe en dimension 2 peut se réaliser en utilisant le code suivant :</p>
    <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from math import *

# valeurs de x, y
x = np.linspace(-3, 2,50)
y = x**2 + 3*x + 1
# construction du graphe
plt.title("Ma première courbe")
plt.xlabel("abscisses")
plt.ylabel("ordonnées")
fig = plt.figure()
graphe = fig.gca()
graphe.plot(x, y, linewidth=1, color="r", label="fonction quadratique")
graphe.legend()
plt.show()</code></pre>

  <img src="./images/courbe2d.png" alt="courbe 2d" width="400">

    <p>Il est possible de modifier la largeur avec le mot-clé linewidth, la couleur avec le mot-clé color parmi les possibilités
    suivantes :</p>

    <table>
        <tr><th>couleur</th><th>code</th></tr>
        <tr><td>blue</td><td>b</td></tr>
        <tr><td>green</td><td>g</td></tr>
        <tr><td>red</td><td>r</td></tr>
        <tr><td>cyan</td><td>c</td></tr>
        <tr><td>black</td><td>k</td></tr>
        <tr><td>white</td><td>w</td></tr>
        <tr><td>yellow</td><td>y</td></tr>
        <tr><td>magenta</td><td>m</td></tr>
    </table>

  <p>La couleur peut également prendre en paramètre une valeur hexadécimale comme cplor="#0f0f0f" par exemple</p>

    <p>Le style de tracé peut se modifier en rajoutant un paramètre dans le code suivant :</p>

    <pre><code class="language-python">plot(x, y, "--", linewidth=1, color="r")</code></pre>

    <p>les styles suivants sont les plus classiques :</p>

    <table>
        <tr><th>style</th><th>code</th></tr>
        <tr><td>pointillés</td><td>--</td></tr>
        <tr><td>points</td><td>:</td></tr>
        <tr><td>points et ronds</td><td>o:</td></tr>
        <tr><td>ligne continue et ronds</td><td>o-</td></tr>
        <tr><td>croix</td><td>x</td></tr>
        <tr><td>ronds</td><td>o</td></tr>
        <tr><td>points et flèches</td><td>&lt:</td></tr>
    </table>

  <h4>Les points</h4>

  <pre><code class="language-python">import matplotlib.pyplot as plt
x = [4.51, 4.87, 5.89, 3.45, 4.89]
y = [56.4, 57.5, 64.2, 57.1, 61.2]
plt.pyplot(x, y, "ob") # o pour rond et b pour blue
plt.xlabel("abscisses")
plt.ylabel("ordonnées")
pt.show()</code></pre>

  <img src="./images/points.png" alt="points" width="400">

    <h4>Les nuages de points</h4>

    <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

nbre_points = 200
r = 2 * np.random.rand(nbre_points)
theta = 2 * np.pi * np.random.rand(nbre_points)
area = 200 * r**2 * np.random.rand(nbre_points)
c12 = plt.scatter(theta, r, c=theta, s=area, cmap=plt.cm.winter)
plt.show()</code></pre>

    <img src="./images/nuagePoints.png" alt="nuage de points" width="400">

    <p>La couleur winter peut être modifiée parmi les couleurs de la gamme cmap (Colormap) :</p>
  <ul>
    <li>'viridis', 'plasma', 'inferno', 'magma', 'cividis'</li>
    <li>'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',
      'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',
      'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn'</li>
    <li>'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink',
      'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia',
      'hot', 'afmhot', 'gist_heat', 'copper'</li>
    <li>'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu',
      'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic'</li>
    <li>'twilight', 'twilight_shifted', 'hsv'</li>
    <li>'Pastel1', 'Pastel2', 'Paired', 'Accent',
      'Dark2', 'Set1', 'Set2', 'Set3',
      'tab10', 'tab20', 'tab20b', 'tab20c'</li>
    <li>'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern',
      'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg',
      'gist_rainbow', 'rainbow', 'jet', 'nipy_spectral', 'gist_ncar'</li>
    <li></li>
  </ul>

  <h4>Courbe 3d</h4>

  <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
import matplotlib as mpl
from math import *
from mpl_toolkits.mplot3d import Axes3D

# valeur du pas
step = 600
# valeur du paramètre
theta = np.linspace(-16 * np.pi, 16 * np.pi, step)
# valeurs de x, y, z
z = np.linspace(-2, 2, step)
r = z**2 + 1
x = r * np.sin(theta)
y = r * np.cos(theta)
# construction du graphe
fig = plt.figure()
graphe = fig.gca(projection='3d')
graphe.plot(x, y, z, label='parametric curve')
graphe.legend()

plt.show()</code></pre>

  <img src="./images/courbe3d.png" alt="courbe 3d" width="400">

  <h4>Surface 3d</h4>

  <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
import matplotlib as mpl
from mpl_toolkits.mplot3d import Axes3D
from math import *

fig = plt.figure()

# construction des axes
graphe = fig.gca(projection='3d')

# construction de la surface 3D
x = np.arange(-7, 0, 0.25)
y = np.arange(-5, 5, 0.25)
x, y = np.meshgrid(0.3*x, 0.4*y)
z = 2*np.exp(-(x**2 + y**2))
surf = graphe.plot_surface(x, y, z, rstride=1, cstride=1, cmap=cm.cividis, linewidth=1, antialiased=True)
graphe.set_zlim(-0.5, 1.5)

fig.colorbar(surf, shrink=0.5, aspect=10)
plt.show()</code></pre>

  <img src="./images/surface3d.png" alt="surface 3d" width="400">

    <h4>Contour plot</h4>

<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np

plt.style.use('seaborn-white')

def f(x,y):
    return np.sin(x)**3 + np.cos(10-y*x) * np.cos(x)**2

x = np.linspace(1.7, 4.6, 500)
y = np.linspace(0.2, 4.7, 500)
X, Y = np.meshgrid(x,y)
Z = f(X, Y)

plt.contourf(X, Y, Z,35, cmap='BrBG')
plt.show()</code></pre>

    <img src="./images/contour.png" alt="contour plot" width="400">

</section> <!-- END CONTENU -->
</section> <!-- END GRAND CONTENU -->
