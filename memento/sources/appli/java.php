<!DOCTYPE HTML>
<html>

<head>
    <meta charset="UTF-8">
    <title> Memento </title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="prism.css">
</head>

<!-- script de gestion des couleurs de code -->
<script defer src="prism.js"></script>

<body>


<div id="bandeau">
    <h1> Memento </h1>
    <h1> Java </h1>

    <nav>
        <div class="element"> <a href="html.html">HTML</a> </div>
        <div class="element"> <a href="css.html">CSS</a> </div>
        <div class="element"> <a href="javascript.html">JAVASCRIPT</a> </div>
        <div class="element"> <a href="java.html">JAVA</a> </div>
        <div class="element"> <a href="kotlin.html">KOTLIN</a> </div>
        <div class="element"> <a href="android.html">ANDROID</a> </div>
        <div class="element"> <a href="php.html">PHP</a> </div>
        <div class="element"> <a href="python.html">PYTHON</a> </div>
        <div class="element"> <a href="c.html">C</a> </div>
        <div class="element"> <a href="git.html">LINUX</a> </div>
    </nav>
</div>

<aside>
    <nav id="table_matiere">
        <a href="">Structure du code</a>
        <a href="">Hello world</a>
        <a href="">Les variables</a>
        <a href="">Chaines de caractères</a>
        <a href="#lien">Les collections</a>
        <a href="#flexbox">Les tableaux</a>
        <a href="">Les conditions</a>
        <a href="">Les boucles</a>
        <a href="">Saisie utilisateur</a>
        <a href="">Input/Output</a>
        <a href="">Les fonctions</a>
        <a href="#hello">Les exceptions</a>
        <a href="">Programmation objet</a>
        <a href="#web">Java au terminal</a>
        <a href="#structure">Les dates</a>
        <a href="#balise">Les balises</a>
        <a href="#menu">La programmation réseau</a>
        <a href="#image">Les proxys</a>
        <a href="#imageTexte">Les sockets</a>
        <a href="#video">RMI</a>
        <a href="#formulaire">JMS</a>
        <a href="#liste">REST</a>
    </nav>
</aside>

<section id="principal">





    <!-- EXECUTER JAVA AU TERMINAL ================================== -->

    <h2 id="javaterminal">Exécuter Java au terminal </h2>



    <p>Pour exécuter un programme Java en utilisant le terminal, il faut d'abord se rendre dans le dossier comportant le fichier, puis compiler le programme avec la commande</p> <pre><code class="language-javascript">javac monFichier.java</code></pre> <p>Le fichier se transforme alors en binaire exécutable par la Machine Virtuelle Java : monFichier.class. Pour exécuter ce programme il reste maintenant à utiliser la commande</p> <pre><code class="language-javascript">java monFichier</code></pre>

        <p>Notons que <em>java -version</em> en ligne de commande permet de vérifier que Java est bien installé.</p>
    </div>


    <!-- LES DATES -------------------------------------------------->

    <h2 id="#dates">Les dates</h2>



        <h3>La classe GregorianCalendar</h3>

    <p>L'utilisation de la classe Date est obsolète. Il est préférable d'utiliser la classe GregorianCalendar qui hérite de la classe abstraite Calendar.</p>
    <p>On peut afficher le timestamp du moment sans formattage particulier en utilisant</p>
    <pre><code class="language-java">new GregorianCalendar().getTime()</code></pre>

    <p>Pour instancier une date à la date du jour, on utilise</p>
    <pre><code class="language-java">GregorianCalendar date = new GregorianCalendar();</code></pre>

    <p>Pour instancier une date à la date du 03/06/2018</p>
    <pre><code class="language-java">GregorianCalendar date = new GreogorianCalendar(2018,05,03);</code></pre>
    <p>car les mois sont notés de 0 à 11.</p>

    <p>Les différents éléments de date sont les suivants :</p>
    <pre><code class="language-java">date.get(Calendar.YEAR);
date.get(Calendar.MONTH);
date.get(Calendar.DAY_OF_MONTH);
date.get(Calendar.DAY_OF_WEEK);</code></pre>

    <p>On remarque que Calendar.YEAR concerne la classe Calendar et non l’objet date. On peut modifier la date prise en compte dans l’objet date de la façon suivante :</p>
    <pre><code class="language-java">date.set(Calendar.YEAR, annee);
date.set(Calendar.MONTH, mois);
date.set(Calendar.DAY_OF_MONTH, jour);
date.set(Calendar.DAY_OF_WEEK, jourDeLaSemaine);</code></pre>

    <fieldset><legend>ATTENTION</legend><p> Calendar.MONTH va de 0 à 11, et 0 est donc le mois de janvier. Calendar.DAY_OF_WEEK va de 1 à 7, et 1 est donc dimanche.</p></fieldset>

    <p>Toutefois, si on veut afficher correctement la date, on peut utiliser</p>
    <pre><code class="language-java">System.out.printf("%04d,%02d,%02d,%02d\n",annee,mois,jour,jourSemaine);</code></pre>

    <p>ou encore formatter de la façon suivante :</p>
    <pre><code class="language-java">SimpleDateFormat formattage = new SimpleDateFormat("yyyy-MM-dd-EEEE");
System.out.println(formattage.format(date.getTime()));</code></pre>

    <p><em>Exemple de saisie clavier de date puis affichage de la date saisie :</em></p>

    <pre><code class="language-java">Scanner saisie = new Scanner(System.in);
System.out.println("entrez année");
int annee = saisie.nextInt();
System.out.println("entrez mois");
int mois = saisie.nextInt();
System.out.println("entrez jour");
int jour = saisie.nextInt();

GregorianCalendar date = new GregorianCalendar(annee,mois,jour);
date.set(Calendar.MONTH, mois-1);
SimpleDateFormat formattage = new SimpleDateFormat("yyyy-MM-dd-EEEE");
System.out.println(formattage.format(date.getTime()));</code></pre>

        <h3>Répétition d'une instruction à l'aide d'un thread</h3>

        <p><em>La classe Timer :</em></p>
        <pre><code class="language-java">import java.util.*;</code></pre>

        <p>Pour répéter une action à intervalles réguliers, on peut utiliser l'équivalent d'un thread avec la classe Timer.</p>

        <pre><code class="language-java">public class Principale {
    public static void main(String[] args) {
        Timer timer = new Timer();
        TimerTask tache = new Action();
        timer.schedule(tache, 2000, 10); // toutes les 2000 ms, 10 répétitions
    }
}</code></pre>

        <p>et la tâche à effectuer plusieurs fois :</p>

        <pre><code class="language-java">public class Action extends TimerTask{
    public void run(){
        System.out.println("hello world");
    }
}</code></pre>

        <p><em>Directement avec la classe Thread :</em></p>
        <p>On peut également obtenir le même résultat sans la classe <em>Timer</em> en utilisant un thread.</p>

        <pre><code class="language-java">public class Principale {
    public static void main(String[] args) {
        Action t = new Action();
        t.start();
    }
}</code></pre>

        <p>et la tâche à effectuer plusieurs fois :</p>
        <pre><code class="language-java">public class TimeThread extends Thread {
    public void run(){
        for(int i=0; i<10; i++) { // 10 répétitions
            try {
                Thread.sleep(2000); // toutes les 2000 ms
                System.out.println("hello world");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>

    </div>



    <!------------- GESTION DES EXCEPTIONS ----------------------->

    <h2>Gestion des exceptions</h2>



    <p>La gestion des exceptions assure l'exécution continue du programme. Elle consiste à repérer un morceau de code qui pourrait générer une erreur, et donner une suite d'instructions à suivre en cas d'erreur pour éviter que le programme s'arrête brutalement.</p>

        <pre><code class="language-java">import java.util.*;</code></pre>

        <p>L'utilisation des mot-clés <em>try-catch-finally</em> gère l'exception. <em>try</em> entoure l'exception, <em>catch</em> indique les instructions à suivre en cas d'erreur, <em>finally</em> est facultatif et indique les instructions à suivre dans tous les cas. La gestion des exceptions peut également servir à analyser les causes de l'erreur.</p>

        <pre><code class="language-java">int j = 20, i = 0;
try {
    System.out.println(j/i);
} catch (ArithmeticException e)
    System.out.println("division par zéro");
}</code></pre>

        <p>L'utilisation du mot-clé <em>throws</em> dans une méthode rejette la gestion de l'exception à la classe qui appelle cette méthode.</p>

        <p>Dans l'exemple suivant, la gestion de l'exception dans le constructeur de Personne est laissée à la classe Principale.</p>

        <pre><code class="language-java">public class Personne {
    public int age = 0;
    public Personne(int age) throws Exception {
       this.age = age;
    }
}

public class Principale {
    public static void main(String[] args) {
        try {
            Personne p = new Personne("Edouard");
            int ageRecherche = p.age - 3; // l'age de la personne il y a 3 ans
        } catch (Exception e) {
            e.printStackTrace();
            e.getClass().getName() + " : " + e.getMessage();
        }
    }
}</code></pre>

<p>Notons la différence entre une erreur de compilation (détectée à l'analyse statique sans exécution du code) et une erreur d'exécution. La levée d'une exception ne concerne que les erreurs d'exécution.</p>




    </div>

    <!------------- LES TABLEAUX ----------------------------->

    <h2>Les tableaux</h2>



        <p>Les tableaux sont des éléments de stockage statiques, dont la taille ne doit pas varier. Ainsi, on ne peut pas rajouter d'élément à un tableau sous peine d'en modifier totalement la structure. Les tableaux sont indexés à partir de 0 et n'admettent pas de système clé-valeur.</p>

        <pre><code class="language-java">import java.util.*;</code></pre>

        <h3>Déclaration d'un tableau</h3>

        <p>Un tableau doit être déclaré en indiquant le type d'objet qu'il contient. Il ne peut pas contenir des objets de types différents. Toutefois, on peut facilement déroger à cette règle en créant des tableaux de type Object qui est très large.</p>

        <pre><code class="language-java">Object[] tab = {"hello", 13, 's'};</code></pre>

        <p>Lors de la déclaration d'un tableau, doit être également précisé le nombre d'éléments qu'il contient. Le typage d'un élément et la taille du tableau ne pourront plus être modifiés ultérieurement.</p>

        <pre><code class="language-java">int[] tab = {12, 1, 34, 21};</code></pre>

        <p>Lors de la déclaration d'un tableau vide, tous les éléments sont initialisés automatiquement, les nombres à 0, les booleans à false, les objets et chaînes de caractères à null.</p>

        <pre><code class="language-java">int[] tab = new int[6];</code></pre>

        <h3>Affichage d'un tableau</h3>

        <pre><code class="language-java">for(int i=0; i&lt tab.length; i++){
    System.out.print(tab[i]+"\t");</code></pre>
        <p>ou encore</p>

        <pre><code class="language-java">for(String valeur : tab){
    System.out.print(valeur+"\t");</code></pre>


    </div>



    <!------------- LES COLLECTIONS ----------------------------->

    <h2>Les collections</h2>



        <pre><code class="language-java">import java.util.*;</code></pre>

    <p>Les collections (ensemble, liste, dictionnaires) sont des conteneurs dynamiques pouvant accepter des objets de types différents et dont la taille varie.</p>

    <p>les ensembles contiennent des éléments non indexés et sans relation d'ordre. On ne peut donc pas y accéder en faisant référence à un String ou un index. Toutefois, on peut parcourir tout l'ensemble et vérifier si un terme appartient à cet ensemble. On les utilise essentiellement pour afficher les éléments d'un dictionnaire après avoir créé un ensemble de clés.</p>

    <p>Les listes contiennent des index auxquels sont associés une valeur unique. Elles s'apparentent à des tableaux sauf que leur taille peut varier et qu'elles peuvent contenir des éléments de types différents.</p>

    <p>Les dictionnaire contiennent des clés auxquelles sont associées une valeur unique.</p>

    <h3>Les listes</h3>

    <table>
        <tr><th>Objectif</th><th>Code</th></tr>
        <tr><td>définir une liste</td><td><pre>ArrayList maListe = new ArrayList();</pre></td></tr>
        <tr><td>définir une liste à partir d'un tableau</td><td><pre>String[] tableau = new String("toto", "tata");
ArraList maListe = new ArrayList(Arrays.asList(tableau));</pre></td></tr>
        <tr><td>définir une liste composée d'un seul type d'élément</td><td><pre>ArrayList&ltString&gt maListe = new ArrayList&ltString&gt();</pre></td></tr>
        <tr><td>ajouter l'élément <em>bonjour</em></td><td><pre>maListe.add("bonjour")</pre></td></tr>
        <tr><td>ajouter l'élément <em>bonjour</em> à l'emplacement d'indice 4</td><td><pre>maListe.add(4, "bonjour")</pre></td></tr>
        <tr><td>remplace l'élément d'indice 4 par <em>bonjour</em></td><td><pre>maListe.set(4, "bonjour")</pre></td></tr>
        <tr><td>renvoyer l'élément d'indice 4</td><td><pre>maListe.get(4)</pre></td></tr>
        <tr><td>renvoyer la taille de maListe</td><td><pre>maListe.size()</pre></td></tr>
        <tr><td>renvoyer l'indice de l'élément <em>bonjour</em></td><td><pre>maListe.indexOf("bonjour")</pre></td></tr>
        <tr><td>supprimer l'élément d'indice 4</td><td><pre>maListe.remove(4)</pre></td></tr>
        <tr><td>comparer l'élément d'indice 4 à celui d'indice 5</td><td><pre>maListe.get(4).equals(maListe.get(5)</pre></td></tr>
        <tr><td>tester si l'élément <em>bonjour</em> appartient à maListe</td><td><pre>maListe.contains("bonjour)</pre></td></tr>
        <tr><td>vider maListe</td><td><pre>maListe.clear()</pre></td></tr>
        <tr><td>copier par valeurs de maListe</td><td><pre>ArrayList listeCopie = (ArrayList) maListe.clone();</pre></td></tr>
    </table>

    <p>ArrayList ne fonctionne qu’avec des types objets pour produire des objets. Ainsi on ne peut pas avoir de liste avec des éléments de type int. Pour pallier ce problème, Java a prévu de faire correspondre à chaque type primitif un objet équivalent. Ainsi au type primitif int correspond l’objet Integer, au type primitif double correspond le type complexe Double. L'autoboxing permet de passer d'un type primitif à son objet correspondant de façon automatisée. En revanche, il convient de déclarer les listes avec les types objet et non les types primitifs. On écrira ainsi :</p>
        <pre><code class="language-java">ArrayList&ltInteger&gt maListe = new ArrayList&ltInteger&gt();</code></pre>

    <p>Attention, la comparaison de 2 éléments ne se fait pas avec l'opérateur == car on compare des objets et non des types primitifs.</p>
    <p>Pour afficher une liste :</p>

        <pre><code class="language-java">Iterator iterateur = maListe.iterator();
while(iterateur.hasNext()) {
    System.out.print(iterateur.next()+"\t");
}</code></pre>

        <pre><code class="language-java">for(int i=0; i&ltmaListe.size();i++) {
    System.out.print(maListe.get(i)+"\t");
}</code></pre>

    <h3>Les dictionnaires</h3>

        <table>
            <tr><th>Objectif</th><th>Code</th></tr>
            <tr><td>définir un dictionnaire</td><td><pre>HashMap&ltString, String&gt dico = new HashMap&ltString, String&gt();</pre></td></tr>
            <tr><td>ajouter l'élément <em>lundi, Monday</em></td><td><pre>dico.put("lundi", "Monday")</pre></td></tr>
            <tr><td>remplace l'élément de clé <em>lundi</em></td><td><pre>dico.put("lundi", "Montag")</pre></td></tr>
            <tr><td>renvoyer la valeur de l'élément de clé <em>lundi</em></td><td><pre>dico.get("lundi")</pre></td></tr>
            <tr><td>renvoyer la taille de dico</td><td><pre>dico.size()</pre></td></tr>
            <tr><td>supprimer l'élément de clé <em>lundi</em></td><td><pre>dico.remove("lundi")</pre></td></tr>
            <tr><td>vider dico</td><td><pre>dico.clear()</pre></td></tr>
        </table>

        <p>Pour afficher un dictionnaire :</p>

        <pre><code class="language-java">HashMap dico = new HashMap();
Set ensemble = dico.keySet();
for(Object clef : ensemble){
    System.out.println(clef+" :"dico.get(clef));
}</code></pre>

        <pre><code class="language-java">Iterator iterateur = ensemble.iterator();
while(iterateur.hasNext()) {
Object clef = iterateur.next();
    System.out.println(clef+":"+dico.get(clef));
}</code></pre>

        <h3>Vector</h3>

        <p>La classe Vector, aujourd'hui désuète, permet de définir des listes dont la taille est fixe, i.e. les objets de classe Vector se manipulent comme des listes mais il faut définir leur taille au moment de la déclaration et ne pas dépasser cette taille. Notons que la classe Vector est compatible avec la synchronisation avec threads. </p>


    </div>


    <!-- ===== LA PROGRAMMATION RESEAU =================================== -->

<h2 id="programmationreseau">La programmation réseau</h2>



<h3>Rappels sur les réseaux</h3>

<p>La communication réseau est initialement définie par le modèle OSI en 7 couches. Toutefois, la plupart des logiciels reposent sur le modèle TCP/IP en 4 couches : réseau, Internet, transport, application. C'est dans cette dernière couche du modèle TCP/IP que se positionne Java.</p>
<p>Notons que par défaut les principaux protocoles de transfert utilisent les ports suivants :</p>
<ul>
    <li>http : port 80</li>
    <li>ftp : port 20 ou 21</li>
    <li>smtp : port 25</li>
</ul>

<h3>La classe InetAddress</h3>

        <pre><code class="language-java">import java.net.*;</code></pre>
<p>Pour manipuler des adresses IP, on utilise la classe InetAddress. Par exemple pour obtenir l'adresse IP d'un site connu par son nom de domaine :</p>
<pre><code class="language-java">try{
    InetAddress adresse = InetAddress.getByName("meteocentrale.ch");
}catch (UnknownHostException e) {
    e.printStackTrace();
}</code></pre>

<p>et pour connaître l'adresse IP de <em>localhost</em> :</p>

    <pre><code class="language-java">try{
    InetAddress adresse = InetAddress.getByName("localhost");
}catch (UnknownHostException e) {
    e.printStackTrace();
}</code></pre>

    <p>Les méthodes associées à la classe InetAddress nécessitent également la gestion de UnknownHostException :</p>
<table>
    <tr><th>Objectif</th><th>Code</th></tr>
    <tr><td>nom de l'hôte (client)</td><td><pre>adresse.getHostName()</pre></td></tr>
    <tr><td>adresse IP</td><td><pre>adresse.getHostAddress()</pre></td></tr>
    <tr><td>teste si l'adresse est de type boucle locale</td><td><pre>adresse.isLoopbackAddress()</pre></td></tr>
</table>

    <p>Certains sites Internet peuvent avoir plusieurs adresses IP :</p>
<pre><code class="language-java">try{
    InetAddress[] adresses = InetAddress.getAllByName("amazon.fr");
    System.out.println("Toutes les adresses IP : ");
    for(InetAddress valeur : adresses) {
        System.out.println(" - " + valeur.getHostAddress());
    }
} catch(UnknownHostException e) {
    e.printStackTrace();
}</code></pre>

<h3>La classe URL</h3>

<p>On peut également utiliser la classe URL pour récupérer les données d'un site Internet :</p>
<pre><code class="language-java">import java.io.*;
import java.net.*;

try {
    URL url = new URL("http://www.meteofrance.fr");
}catch(MalformedURLException e) {
    e.printStackTrace();
}</code></pre>

    <p>Les méthodes associées à la classe URL nécessitent également la gestion de MalformedURLException.</p>

<table>
    <tr><th>Objectif</th><th>Code</th></tr>
    <tr><td>nom du site</td><td>url.getAuthority()</td></tr>
    <tr><td>port par défaut</td><td>url.getDefaultPort()</td></tr>
    <tr><td>nom de l'hébergeur</td><td>url.getHost()</td></tr>
    <tr><td>numéro de port spécifié</td><td>url.getPort()</td></tr>
    <tr><td>protocole</td><td>url.getProtocol()</td></tr>
</table>

<p>Lorsque url.getPort() renvoie -1, cela signifie que le port n'a pas été spécifié dans l'URL.</p>

<p>Pour vérifier qu'une saisie utilisateur correspond à une url, on peut par exemple utiliser la condition :</p>
<pre>if(host.matches("[a-zA-Z\\.]+"))</pre>

    </div>





    <!-- ===== LES PROXYS ======================================= -->

    <h2 id="proxys">Les proxys</h2>



        <p>Un proxy constitue une autre façon de se connecter à un serveur. Le proxy est un intermédiaire faisant le lien entre le client et le serveur.</p>
        <pre><code class="language-java">import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.Socket;
import java.net.SocketAddress;

//On crée une adresse correspondant à notre proxy
SocketAddress proxyAddress = new InetSocketAddress("10.10.10.10", 8080);

//On instancie la classe Proxy avec le type souhaité
Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);

//On crée notre socket utilisant le proxy
Socket s = new Socket(proxy);

//On crée l'adresse que l'on souhaite atteindre via le proxy
SocketAddress remote = new InetSocketAddress("www.adret-attitude.ch", 80);
try {
    //On connecte le tout !
    s.connect(remote);
} catch (IOException e) {
    e.printStackTrace();
}</code></pre>

        <p></p>

        <table>
            <tr><th>Objectif</th><th>Code</th></tr>
            <tr><td>port côté serveur</td><td>s.getPort()</td></tr>
            <tr><td>port côté client</td><td>s.getLocalPort()</td></tr>
            <tr><td>nom hôte distant</td><td>s.getInetAddress().getHostName()</td></tr>
            <tr><td>adresse hôte distant</td><td>s.getInetAddress().getHostAddress()</td></tr>
            <tr><td>adresse socket hôte distant</td><td>s.getRemoteSocketAddress()</td></tr>
        </table>

        <pre><code class="language-java">try {
    Socket s = new Socket("www.adret-attitude.ch", 80);
    System.out.println("Port de communication côté serveur : " + s.getPort());
    System.out.println("Port de communication côté client : " + s.getLocalPort());
    System.out.println("Nom de l'hôte distant : " + s.getInetAddress().getHostName());
    System.out.println("Adresse de l'hôte distant : " + s.getInetAddress().getHostAddress());
    System.out.println("Adresse socket de l'hôte distant : " + s.getRemoteSocketAddress());
} catch (UnknownHostException e) {
        e.printStackTrace();
} catch (IOException e) {
        e.printStackTrace();
}</code></pre>

    </div>





<!-- ===== LES SOCKETS =================================== -->

<h2 id="programmationclientserveur">Les sockets</h2>



        <div class="pcle"><strong>API Application Programming Interface</strong> : ensemble normalisé de classes, de méthodes qui sert de façade par laquelle un logiciel offre des services à d'autres logiciels. C'est la partie du programme qu'on expose au monde extérieur pour manipuler celui-ci. Ces services sont offerts à travers une bibliothèque ou un service Web. L'API est au développeur ce que l'User Interface est à l'utilisateur.</div>

        <p>Les sockets sont des API qui gèrent les communications entre programmes au sein d'une structure client-serveur. La communication entre sockets nécessite l'adresse du serveur, le port compris entre 1024 et 65536, et l'utilisation d'un protocole (TCP ou UDP). Une caractéristique des sockets est la suivante :</p>
        <ul>
            <li>les sockets travaillent en full-duplex i.e. une même socket sert aussi bien à envoyer qu'à recevoir des données. Il n'y a donc pas de file d'attente. Toutefois certaines méthodes comme accept() sont des fonctions bloquentes qui ne libèrent pas le programme tant qu'un traitement n'a pas été fait.</li>

        </ul>

        <pre><code class="language-java">import java.io.*;
import java.nio.*;
import java.util.*;
import java.net.*;</code></pre>

    <h3>Le mode connecté</h3>

    <p>En mode connecté, deux sockets établissent une communication durable entre l'émetteur et le récepteur, ce qui permet d'éviter de transmettre l'adresse du récepteur à chaque envoi et gère l'acquittement des données. Dans ce cas, le serveur est vu comme un programme rendant des services aux clients. Le mode connecté utilise le protocole TCP. Exemple d'application, le protocole HTTP.</p>

        <p>Le serveur crée une socket de connexion sur un port défini, puis attend la demande de communication venant d'un client pour ouvrir une socket de communication. De son côté, le client crée une socket de communication à l'adresse du serveur et sur le port défini.</p>

        <img src="images/socket.png" height="300" width="750">

    <p>Les méthodes de la classe Socket permettant d'obtenir des informations sur la connexion et nécessitent également la gestion de IOException :</p>

    <table>
        <tr><th>Instruction</th><th>Résultat</th></tr>
        <tr><td><pre><code class="language-javascript">socket_client.getInetAddress()</code></pre></td><td>fournit l'adresse IP distante</td></tr>
        <tr><td><pre><code class="language-javascript">socket_client.getLocalAddress()</code></pre></td><td>fournit l'adresse IP locale</td></tr>
        <tr><td><pre><code class="language-javascript">socket_client.getPort()</code></pre></td><td>fournit le nmr de port distant</td></tr>
        <tr><td><pre><code class="language-javascript">socket_client.getLocalPort()</code></pre></td><td>fournit le nmr de port local</td></tr>
    </table>

    <p>La machine virtuelle Java ferme les sockets non utilisés à la fin de l'exécution du programme. Toutefois, le nombre de sockets ouvertes par un programme est limité, ce qui conduit à des erreurs quand cette limite est atteinte. La méthode close() permet de fermer la connexion.</p>

        <fieldset><legend>IMPORTANT</legend><p>La socket côté serveur doit être lancée avant la socket côté client.</p></fieldset>

        <h3>Exemple de transmission d'un entier par TCP :</h3>

        <p>Dans cet exemple un serveur transmet un entier à un client.</p>

        <p>Il n'est pas nécessaire de transmettre la taille des String avec le message lorsqu'on utilise les méthodes writeUTF() et readUTF() qui détectent automatiquement la taille des String dans un flux. La quantité d'information transmise est donnée par message.length() si on note message la variable représentant le message reçu.</p>

        <img src="images/socketChaine.png">

        <p><em>Côté serveur</em>  </p>

        <pre><code class="language-java">public class ServeurTCP {

    public static void main(String[] args) {
        try {
            // creation socket serveur de connexion sur le port 5555
            ServerSocket srv = new ServerSocket(5555);
            // creation socket serveur de communication a la demande d'un client
            Socket com = srv.accept();

            // communication sortante vers le client
            DataOutputStream dos = new DataOutputStream(com.getOutputStream());
            dos.writeInt(1420);

            // fermeture communication
            com.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client</em> </p>

        <pre><code class="language-java">public class ClientTCP {

    public static void main(String[] args) {
        try {
            Socket clt = new Socket("nomServeur", 5555);

            // communication entrante en provenance du serveur
            DataInputStream dis = new DataInputStream(clt.getInputStream());
            System.out.println("Message received: " + dis.readInt());

            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <h3>Exemple d'un échange de chaînes de caractères par TCP :</h3>

        <p>Dans cet exemple, un client transmet "hello" à un serveur qui lui répond "world".</p>

        <p><em>Côté client</em></p>

        <pre><code class="language-java">public class ClientTCP {
    public static void main(String[] args) {
        try {
            // creation socket client de communication sur le port 5555
            // Socket clt = new Socket("adresseServeur", 5555); ou
            Socket clt = new Socket("nomServeur", 5555);

            DataOutputStream dos = new DataOutputStream(clt.getOutputStream());
            dos.writeUTF("hello");

            DataInputStream dis = new DataInputStream(com.getInputStream());
            System.out.println(dis.readUTF());

            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté serveur</em></p>

        <pre><code class="language-java">public class ServeurTCP {

    public static void main(String[] args) {
        try {
            ServerSocket srv = new ServerSocket(5555);
            Socket com = srv.accept();

            DataInputStream dis = new DataInputStream(com.getInputStream());
            System.out.println(dis.readUTF());

            DataOutputStream dos = new DataOutputStream(clt.getOutputStream());
            dos.writeUTF("world");

            com.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <h3>Exemple de transmission d'un objet par TCP :</h3>

        <p>Dans cet exemple, un client transmet un objet sous forme de message au serveur.</p>

        <p><em>Côté client</em></p>

        <pre><code class="language-java">public class ClientTCP {

    public static void main(String[] args) {
        try {
            Socket clt = new Socket("nomHote", 5555);
            // communication sortante, les data sont placees dans un objet transmis sous forme de Message
            DataOutputStream dos = new DataOutputStream(clt.getOutputStream());
            ObjectOutputStream oos = new ObjectOutputStream(dos);

            Message mess = new Message("nicolas", new Date(), "hello world");
            oos.writeObject(mess);

            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté serveur</em> </p>

        <pre><code class="language-java">public class ServeurTCP {

    public static void main(String[] args) {

        try {
            ServerSocket srv = new ServerSocket(5555);
            Socket com = srv.accept();
            // communication entrante, les data sont placees dans un objet
            // transforme en Message, puis en String pour affichage
            DataInputStream dis = new DataInputStream(com.getInputStream());
            ObjectInputStream ois = new ObjectInputStream(dis);

            Message mess = (Message) ois.readObject();
            System.out.println("Message reçu : " + mess.toString());

            com.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) { // doit apparaitre
            e.printStackTrace();
        }
    }
}</code></pre>

        <p>et la classe Message présente côté serveur et côté client, qui implémente l'interface Serializable nécessaire pour transmettre le message sous forme de data :</p>

        <pre><code class="language-java">public class Message implements Serializable{
    // un objet de type Message doit etre serialisable pour pouvoir etre transmis
    String name;
    Date date;
    String contenu;

    public Message(String name, Date date, String contenu){
        this.name = name;
        this.date = date;
        this.contenu = contenu;
    }

    @Override
    public String toString(){
        return "message = [ " + name + " , " + date+" , "+contenu +" ]";
    }
}</code></pre>

        <h3>Exemple de serveur connecté dynamiquement à plusieurs clients par TCP :</h3>

        <p>Dans cet exemple, 10 clients transmettent un objet de type Message au serveur.</p>

        <p>Il faut créer autant de sockets de communications qu'il y a de clients. Mais le serveur ne traite qu'un seul client à la fois. Si ce traitement prend du temps, les autres clients peuvent être bloqués. Pour éviter ce problème, la gestion des connexions peut être pilotée par des threads. On peut utiliser une création dynamique de threads au fur et à mesure des besoins. Dans ce cas, il est problématique de créer une infinité de threads.</p>

        <p><em>Côté client</em></p>

        <pre><code class="language-java">public class ClientTCP {

    public static void main(String[] args) {
        try {
            Socket clt = new Socket("nomServeur", 5555);
            DataOutputStream dos = new DataOutputStream(clt.getOutputStream());
            ObjectOutputStream oos = new ObjectOutputStream();

            Message mess = new Message("tom", new Date(), "hello world");
            oos.writeObject(mess);

            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté serveur</em></p>

        <pre><code class="language-java">public class ServeurTCP {
    public static void main(String[] args) {
        try {
            ServerSocket srv = new ServerSocket(5555);

            for(int i=0; i<10; i++){ // pour 10 clients
                Socket com = srv.accept();

                ServerThread t = new ServerThread(com);
                t.start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

public class ServerThread extends Thread { // gestion des threads pour chaque communication
    Socket com;

    public ServerThread(Socket com) {
        this.com = com;
    }

    public void run() {
        try{
            DataInputStream dis = new DataInputStream(com.getInputStream());
            ObjectInputStream ois = new ObjectInputStream();
            while(!fin){
                Message mess = (Message) ois.readObject();
                System.out.println(mess.toString());
            }
            com.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Présent des deux côtés :</em></p>

        <pre><code class="language-java">public class Message implements Serializable{
    String nom;
    Date date;
    String contenu;

    public Message(String nom, Date date, String contenu){
        this.nom = nom;
        this.date = date;
        this.contenu = contenu;
    }

    @Override
    public String toString(){
        return "nom :"+nom+", date :"+date+", contenu :"+contenu;
    }
}</code></pre>

        <h3>Exemple de serveur connecté par un pool de threads à plusieurs clients par TCP :</h3>

        <p>Dans cet exemple, 10 clients transmettent un objt de type Message au serveur. Pour éviter la création d'une infinité de threads dynamiques, on peut utiliser un pool de threads qui arrêtent les sockets de communication lorsque le traitement est terminé pour se connecter aux sockets de communication restantes.</p>

        <p><em>Côté client</em></p>

        <pre><code class="language-java">public class ClientTCP {

    public static void main(String[] args) {
        try {
            Socket clt = new Socket("nomServeur", 5555);
            DataOutputStream dos = new DataOutputStream(clt.getOutputStream());
            ObjectOutputStream oos = new ObjectOutputStream();

            Message mess = new Message("Nicolas", new Date(), "hello world");
            oos.writeObject(mess);

            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté serveur</em></p>

        <p>Le serveur commence par créer un ensemble de threads en attente de recevoir une demande de connexion. Lorsqu'un client demande une connexion, elle est prise en charge par un des threads.</p>

        <pre><code class="language-java">public class ServeurTCP {
    public static void main(String[] args) {
        try {
            ServerSocket srv = new ServerSocket(5555);
            ServerThread[] pool = new ServerThread[8]; // on choisit de travailler avec 8 threads

            for(ServerThread t : pool) {
                t = new ServerThread(srv);
                t.start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

public class ServerThread extends Thread { // gestion des threads pour chaque communication
    ServerSocket srv;

    public ServerThread(ServerSocket srv) {
        this.srv = srv;
    }

    public void run() {
        try{
            for(int i=0; i<11; i++) { // on considère 10 clients
                Socket com = srv.accept();
                DataInputStream dis = new DataInputStream(com.getInputStream());
                ObjectInputStream ois = new ObjectInputStream();

                while(!fin) {
                    Message mess = (Message) ois.readObject();
                    System.out.println(mess.toString());
                }
                com.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Présent des deux côtés :</em></p>

        <pre><code class="language-java">public class Message implements Serializable{
    String nom;
    Date date;
    String contenu;

    public Message(String nom, Date date, String contenu){
        this.nom = nom;
        this.date = date;
        this.contenu = contenu;
    }

    @Override
    public String toString(){
        return "nom :"+nom+", date :"+date+", contenu :"+contenu;
    }
}</code></pre>

        <h3>Le mode non connecté</h3>

    <p>En mode non connecté, l'émetteur envoie les données au récepteur en précisant l'adresse du destinataire dans les paquets. La communication utilise dans ce cas le protocole UDP qui ne gère pas l'acquittement des données. Exemple d'application, le flux audio/vidéo car le manque d'acquittement des données optimise la bande passante.</p>
<p>Notons que TCP est plus sécurisé que UDP et UDP est plus rapide que TCP.</p>

    <fieldset><legend>IMPORTANT</legend><p>En mode non connecté, le programme récepteur doit être lancé en premier.</p></fieldset>

        <h3>Exemple de transmission d'un entier par UDP :</h3>

        <img src="images/datagram.png">

        <p>L'entier est transformé en tableau de bytes avant d'être envoyé. A la réception ce tableau de bytes est transformé en entier pour être exploité.</p>

        <p><em>Côté émetteur</em> </p>

        <pre><code class="language-java">public class EmetteurUDP {

    public static void main(String[] args) {
        try {
            // comme la socket de communication n'est utilisée que pour émettre,
            // elle ne définit pas de port de réception
            DatagramSocket emt = new DatagramSocket();

            // recuperation de l'adresse IP du recepteur
            InetAddress adresseIP = InetAddress.getByName("nomRecepteur");
            // transformation de l'entier en byte[]
            byte[] buffer =  ByteBuffer.allocate(4).putInt(1402).array();
            // envoi du paquet
            DatagramPacket paquet = new DatagramPacket(buffer, buffer.length, adresseIP, 5555);
            emt.send(paquet);

            emt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté récepteur</em> </p>

        <pre><code class="language-java">public class RecepteurUDP {

    public static void main(String[] args) {
        try {
            // creation de la socket de communication sur le port 5555 du serveur
            DatagramSocket rcp = new DatagramSocket(5555);

            // creation d'un buffer pour contenir le message a recevoir
            byte[] buffer = new byte[256];
            //reception du paquet
            DatagramPacket paquet = new DatagramPacket(buffer, buffer.length);
            rcp.receive(paquet);
            // conversion du message reçu en byte[] vers un entier
            System.out.println("Message reçu :  " + ByteBuffer.wrap(buffer).getInt());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <h3>Exemple d'un échange de chaînes de caractères entre un serveur et un client par UDP :</h3>

        <p>Dans cet exemple, le client envoie le message "hello" et le serveur répond "world".</p>
        <p>La socket côté serveur recevra les données sur le port 5555 du serveur et elle pourra également émettre. Dans ce cas elle utilisera le port défini par le client et l'adresse du client, qui seront précisés dans le paquet d'envoi.</p>

        <p><em>Côté client </em></p>

        <pre><code class="language-java">public class ClientUDP {

    public static void main(String[] args) {
        try {
            // la socket recevra les données sur le port 4444
            // elle enverra les données sur le port défini dans le paquet d'envoi
            DatagramSocket clt = new DatagramSocket(4444);

            // envoi de paquet1
            InetAddress adresseIP = InetAddress.getByName("nomServeur");
            String mess = "hello";
            DatagramPacket paquet1 = new DatagramPacket(mess.getBytes(), mess.getBytes().length, adresseIP, 5555);
            clt.send(paquet1);

            // reception du paquet2
            byte[] buffer = new byte[256];
            DatagramPacket paquet2 = new DatagramPacket(buffer, buffer.length);
            clt.receive(paquet2);
            System.out.println("Message recu =  " + new String(buffer));

            clt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté serveur</em> </p>

        <pre><code class="language-java">public class ServeurUDP {

    public static void main(String[] args) {
        try {
            // la socket recevra les données sur le port 5555
            // elle enverra les données sur le port défini dans le paquet d'envoi
            DatagramSocket srv = new DatagramSocket(5555);

            // reception du paquet1
            byte[] buffer = new byte[256];
            DatagramPacket paquet1 = new DatagramPacket(buffer, buffer.length);
            srv.receive(paquet1);
            System.out.println("Message recu =  " + new String(buffer));

            // envoi de paquet2
            InetAddress adresseIP = InetAddress.getByName("nomClient");
            String mess = "world";
            DatagramPacket paquet2 = new DatagramPacket(mess.getBytes(), mess.getBytes().length, adresseIP, 4444);
            srv.send(paquet2);

            srv.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>



    </div>



    <!-- Le RMI ------------------------------>

    <h2 id="mecanismermi">RMI Remote Method Invocation</h2>



    <p>Le mécanisme RMI permet d'appeler du code à distance, en créant un objet distant sur un serveur. Notons que l'appel à distance est bloquant. Cette technique offre pour avantages de mettre à jour le client de manière transparente et de masquer l'exécution distante du code tout en travaillant comme si l'exécution était locale.</p>

        <pre><code class="language-java">import java.rmi.*;
import java.rmi.server.*;
import java.util.*;
import java.io.*;
import java.net.*;</code></pre>

        <h3>Fonctionnement d'une communication par RMI</h3>

        <p>Le serveur implémente un objet distant qui est publié dans un serveur de noms (<em>registry</em>), i.e. qu'il est associé à un nom à partir duquel les applications clientes pourront récupérer un talon de cet objet. Pour ce faire, Java crée automatiquement sur le serveur une représentation distante appelée <em>skeleton</em> et sur le client une représentation locale appelée <em>stub</em>, qui sont transparentes pour le programmeur car elles n'apparaissent pas dans les différentes classes. Le client utilise alors ce <em>stub</em> comme si l'objet distant était local.</p>

        <img src="images/rmi.png">

        <h3>Exemple d'utilisation d'une méthode distante côté serveur :</h3>

        <p>On présente ici un exemple où le client appelle une procédure sayHello présente côté serveur pour afficher <em>Hello bob</em> côté serveur.</p>

        <pre><code class="language-java">public interface Hello extends Remote {
    public void sayHello(String nom) throws RemoteException;
}</code></pre>

    <p><em>Côté serveur :</em></p>

    <p>L'implémentation de l'interface se fait côté serveur et ne doit pas être présente côté client.</p>

    <pre><code class="language-java">public class HelloImpl extends UnicastRemoteObject implements Hello {
    public HelloImpl() throws RemoteException {
        super();
    }
    public void sayHello(String nom) throws RemoteException {
        System.out.println("Hello "+nom);
    }
}</code></pre>

    <p>Dans la classe principale côté serveur, il faut instancier l'implémentation.</p>

    <pre><code class="language-java">public class ServeurHello {
    public static void main(String[] args) {
        try {
            // creation de l'objet distant
            HelloImpl objetDistant = new HelloImpl();
            // publication de objetDistant dans le serveur de noms, ce qui crée le skeleton
            Naming.rebind("repertoirehello", objetDistant);
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client :</em></p>

    <p>L'appel côté client d'une méthode d'un objet distant consiste à obtenir une référence sur l'objet distant puis à appeler la méthode à partir de cette référence.</p>
    <pre><code class="language-java">public class ClientHello {
    public static void main(String[] args) {
        try {
            // args[0] represente l'url qui sera le 1er argument entre en ligne de commande
            // lors de l'exécution de java Client localhost:5555, donc ici localhost:5555
            // le fait de pointer vers l'adresse de l'interface Hello cree le stub
            Hello obj = (Hello) Naming.lookup("//"+args[0]+"/repertoirehello");
            obj.sayHello("bob");
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (NotBoundException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p>La gestion de sécurité se réalise à travers une instance de la classe java.rmi.RMISecurityManager, à la fois côté client et serveur :</p>
<pre><code class="language-java">if(System.getSecurityManager()==null){
    System.setSecurityManager(new RMISecurityManager());
}</code></pre>

<p>qui nécessite la bibliothèque :</p>
        <pre><code class="language-java">import java.lang.*;</code></pre>

        <p>Il faut ensuite rajouter dans le package courant le fichier <em>policy</em> suivant :</p>
        <pre><code class="language-java">grant{
    permission java.net.SocketPermission "*:1024-65535", connect,accept";
    permission java.net.SocketPermission "*:80", "connect";
}</code></pre>

        <p>ou encore pour tout permettre :</p>

        <pre><code class="language-java">grant{
    permission java.security.AllPermission;
}</code></pre>

        <h3>Exemple d'utilisation d'une méthode distante côté client :</h3>

        <p>On présente un exemple où le client appelle une procédure sayHello présente côté serveur pour afficher <em>Hello bob</em> côté client.</p>

        <pre><code class="language-java">public interface Hello extends Remote {
    public String sayHello(String nom) throws RemoteException;
}</code></pre>

        <p><em>Côté serveur :</em></p>

        <pre><code class="language-java">public class HelloImpl extends UnicastRemoteObject implements Hello {
    public HelloImpl() throws RemoteException {
        super();
    }
    public String sayHello(String nom) throws RemoteException {
        return "Hello "+nom;
    }
}</code></pre>

        <pre><code class="language-java">public class ServeurHello {
    public static void main(String[] args) {
        try {
            // creation de l'objet distant
            HelloImpl objetDistant = new HelloImpl();
            // publication de objetDistant dans le serveur de noms, ce qui crée le skeleton
            Naming.rebind("repertoirehello", objetDistant);
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client :</em></p>

         <pre><code class="language-java">public class ClientHello {
    public static void main(String[] args) {
        try {
            // args[0] represente l'url qui sera le 1er argument entre en ligne de commande
            // lors de l'exécution de java Client localhost:5555, donc ici localhost:5555
            // le fait de pointer vers l'adresse de l'interface Hello cree le stub
            Hello obj = (Hello) Naming.lookup("//"+args[0]+"/repertoirehello");
            System.out.print(obj.sayHello("bob"));
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (NotBoundException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <h3>Exemple d'une boite de messagerie par RMI :</h3>

        <p>Dans cet exemple, le client peut s'inscrire à un service de messagerie, envoyer un message composé d'un identifiant, du nom d'utilisateur, la date et le contenu, consulter le dernier message d'un client par son nom d'utilisateur. Pour cela, on écrase les messages d'un utilisateur au fur et à mesure de leur envoi. Le serveur annonce à tous les clients lorsqu'un utilisateur s'inscrit.</p>

<p><em>L'interface :</em></p>

<pre><code class="language-java">public interface Boite extends Remote{
    public void inscrire(String user, Notification) throws RemoteException;
    public void envoyerMessage(Message message) throws RemoteException;
    public Message getMessage(int id) throws RemoteException;
}</code></pre>

    <p><em>Côté serveur :</em></p>

        <p>l'implémentation :</p>
<pre><code class="language-java">public class BoiteImpl extends UnicastRemoteObject implements Boite{
    HashMap&ltInteger,Contact&gt tableContact = new HashMap&ltInteger,Contact&gt();
    int nbContact;
    HashMap&ltInteger, Message&gt tableMessage = new HashMap&ltInteger, Message&gt();

    public BoiteImpl() throws RemoteException{
        super();
        nbContact = 0;
    }

    @Override
    public void inscrire(String nom, Notification obj) throws RemoteException{
        nbContact += 1;
        Contact c = new Contact(nbContact, nom, obj);
        tableContact.put(nbContact, c);

        Set ensemble = tableContact.keySet();
        for(Object clef : ensemble){
            tableContact.get(clef).obj.informerInscription(c.nom);
    }

    public void envoyerMessage(int idClient, Message message) throws RemoteException{
        tableMessage.put(idClient, message);
    }

    public Message getMessage(int idClient) throws RemoteException {
        return tableMessage.get(idClient);
    }
}</code></pre>

    <p>et la classe principale :</p>
<pre><code class="language-java">public class ServeurBoite {
    public static void main(String[] args){
        try{
            BoiteImpl objDistant = new BoiteImpl();
            Naming.rebind("DossierBoite", objDistant);
        }catch(RemoteException e){
            e.printStackTrace();
        }catch(MalformedURLException e){
            e.printStackTrace();
        }
    }
}</code></pre>

    <p><em>Côté client :</em></p>

<pre><code class="language-java">public class Client {
    public static void main(String[] args){
        try{
            Boite obj = (Boite)Naming.lookup("//"+args[0]+"/DossierBoite");
            obj.inscrire("bob", new NotificationImpl());
            Message mess = new Message(113, "Mike", new Date(), "hello");
            obj.envoyerMessage(mess);
            System.out.println("message : "+obj.getMessage(113).toString());
        }catch(RemoteException e){
            e.printStackTrace();
        }catch(NotBoundException e){
            e.printStackTrace();
        }catch(MalformedURLException e){
            e.printStackTrace();
        }
    }
}</code></pre>

        <p>L'interface côté client pour que le serveur envoie un message à tous les clients leur indiquant la connexion d'un client :</p>

        <pre><code class="language-java">public interface Notification extends Remote{
    public void informerInscription(String nom) throws RemoteException;
}</code></pre>

        <p>l'implémentation côté client :</p>

        <pre><code class="language-java">public class NotificationImpl extends UnicastRemoteObject implements Notification{
    public NotificationImpl() throws RemoteException{
        super();
    }

    @Override
    public void informerInscription(String nom) throws RemoteException{
        System.out.println(nom+" vient de se connecter");
    }
}</code></pre>

        <p>Si les objets distants attendent la connexion en permanence, les ressources mémoire sont monopolisées inutilement. Pour cette raison, on préfère créer des objets distants activables. L'utilisation de la classe UnicastRemoteObject est réservée au développement d'objets distants temporaires.</p>
        <p>Notons que l'application cliente devra également gérer la synchronisation des appels à distance à l'aide de threads pour éviter le blocage du système.</p>

        <p>La gestion de sécurité est modifiée pour pouvoir créer le groupe d'activation :</p>

        <pre><code class="language-java">grant{
    permission java.net.SocketPermission "machine:*", accept, resolve";
}</code></pre>

        <p><em>côté serveur et côté client :</em></p>

        <p>La classe Message :</p>
        <pre><code class="language-java">public class Message implements Serializable{
    int id;
    String nom;
    Date date;
    String contenu;

    public Message(int id, String nom, Date date, String contenu) {
        this.id = id;
        this.nom = nom;
        this.date = date;
        this.contenu = contenu;
    }

    @Override
    public String toString(){
        return "Le "+date+" "+nom+" a écrit : "+contenu;
    }
}</code></pre>

        <pre><code class="language-java">public class Contact{
    int id;
    String nom;
    Notification obj;

    public Contact(int id, String nom, Notification obj){
        this.id = id;
        this.nom = nom;
        this.obj = obj;
    }
}</code></pre>

        <fieldset><legend>ATTENTION</legend><p>Lors d'un appel distant les paramètres, les valeurs de retour et les exceptions sont transmis par copie et doivent donc être sérialisables. Or les types primitifs et les objets distants le sont par défaut. En revanche, les types créés ne sont pas sérialisables mais peuvent le devenir si les classes correspondantes implémentent l'interface Serializable.</p></fieldset>

<h3>Activation d'objets distants</h3>

        <p>L’activation permet d’éviter l’exposition permanente des objets distants de la classe UnicastRemoteObject. L’objectif est de créer automatiquement des objets RMI à la demande. Ce mécanisme nécessite une référence permanente.</p>

        <h3>Exemple d'activation e transmission d'une chaîne de caractères par RMI :</h3>

        <pre><code class="language-java">import java.rmi.*;
import java rmi.activation.*;
import java.util.*;</code></pre>

        <p>On présente ici une procédure où le client affiche <em>Hello Mike</em> en utilisant la procédure <em>sayHello</em> présente sur le serveur.</p>

        <p><em>Côté serveur :</em></p>

        <pre><code class="language-java">public interface Hello extends Remote {
    public void sayHello(String nom) throws RemoteException;
}</code></pre>

        <p>L'implémentation de l'interface se fait côté serveur et ne doit pas être présente côté client.</p>

        <pre><code class="language-java">public class HelloImpl extends Activatable implements Hello {
    public HelloImpl(ActivationID id, MarshalledObject data) throws RemoteException {
        super(id, 0);
    }
    public void sayHello(String nom) throws RemoteException {
        System.out.println("hello "+nom);
    }
}</code></pre>

        <p>Dans la classe principale côté serveur, il faut instancier l'implémentation.</p>

        <pre><code class="language-java">public class ServeurHello {
    public static void main(String[] args) {
        try { // creation de l'objet distant activable
            System.setSecurityManager(new RMISecurityManager();
            Properties prop = new Properties();
            prop.put("java.security.policy", "java.policy");
            ActivationGroupDesc agd = new ActivationGroupDesc(prop, null);
            ActivationGroupID agi = ActivationGroup.getSystem().registerGroup(agd);
            //MarshalledObject data = new MarshalledObject(new Donnees(" Boite Vio ", 2 0));
            ActivationDesc ad = new ActivationDesc(agi, "DossierHello.HelloImpl", arg[0], null);
            Hello objetDistant = (Hello) Activatable.register(ad);

            Naming.rebind("DossierHello", objetDistant);
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p>Il faut toutefois modifier la politique de sécurité afin de pouvoir créer le groupe d'activation. Le fichier de politique de sécurité est le suivante :</p>

        <pre><code class="language-java">grant {
    // nécessaire pour créer le groupe d'activation
    permission java.net.SocketPermission "localhost:*","accept,resolve";
};</code></pre>

        <p><em>Côté client :</em></p>

        <p>L'appel côté client d'une méthode d'un objet distant consiste à obtenir une référence sur l'objet distant puis à appeler la méthode à partir de cette référence.</p>
        <pre><code class="language-java">public class ClientHello {
    public static void main(String[] args) {
        try {
            // args[0] represente l'url qui sera le 1er argument entre en ligne de commande
            // lors de l'exécution de java Client localhost:5555, donc ici localhost:5555
            // le fait de pointer vers l'adresse de l'interface Hello cree le stub
            Hello obj = (Hello) Naming.lookup("//"+args[0]+"/DossierHello");
            obj.sayHello("Mike");
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (NotBoundException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>


    </div>



    <!-- JMS --------------------------------------->

    <h2 id="jms">JMS Java Message Service</h2>



        <div class="pcle"><strong>message</strong> : ensemble de données groupées pour être envoyées et reçues en même temps.</br>
            <strong>serveur d'application :</strong> infrastructure offrant un contexte d'exécution pour des composants applicatifs.</br>
    <strong>JNDI Java Naming and Directory Interface</strong> : il s'agit d'une API Java de connexion à des annuaires, permettant d'accéder à différents services, d'organiser et de rechercher des informations par nommage. JNDI fait partie de Java EE, il est trés utilisé dans les serveurs d'application et nécessite le package naming</div>

    <p>JMS est une API spécialisée dans le service de messagerie (création, envoi et lecture de messages) d'une application à une autre sur un poste distant. JMS utilise un MOM Message Oriented Middleware de type JMSConnectionFactory géré par un fournisseur tels que Apache ActiveMQ qui joue le rôle de plateforme de messagerie. Les particularités de JMS sont les suivantes :</p>
        <ul>
            <li>la communication est asynchrone, un message arrivera au client sans qu'il n'ait fait de requête</li>
            <li>JMS est fiable, car il s'assure que le message est bien délivré</li>
        </ul>

        <pre><code class="language-java">import java.util.*;
import javax.naming.*;
import javax.jms.*;</code></pre>

        <h3>Fonctionnement de JMS</h3>

        <p>Les messages sont envoyés sur un objet intermédiaire MOM qui utilise une structure de file d'attente (queue) ou de sujet (topic), et le récepteur doit venir les chercher. Des bus gèrent les transports de messages vers les objets intermédiaires. De ce fait, il n'y a pas de connexion entre un émetteur et un récepteur. Les récepteurs actifs peuvent voir tous les messages délivrés par l'émetteur, mais celui-ci ne connaît pas  l'état des récepteurs actifs. Les récepteurs peuvent s'inscrire comme DurableSubscriber avec JMS2.0 et dans ce cas, les messages qu'ils n'ont pas consultés durant leur absence peuvent être lus au moment où ils se reconnectent.</p>

        <img src="images/jms.png">

        <p>Ce mode de communication indirect permet de mettre en place des services avancés :</p>
    <ul>
        <li>communication de groupe (multicast)</li>
        <li>envoi et réception groupés</li>
        <li>retransmission des messages en cas de non réception</li>
        <li>trace des échanges (log)</li>
        <li>gestion des droits d'accès</li>
    </ul>

        <h3>Queue et Topic</h3>

        <p>JMS repose sur deux modes de communication principaux, la communication point-à-point et la communication événementielle.</p>
        <p> Dans la communication point-à-point, l'objet intermédiaire utilise une file d'attente (queue). Plusieurs émetteurs peuvent envoyer sur la même file d'attente mais un seul récepteur peut voir le message. On parle de communication N à 1. C'est le cas par exemple lorsqu'on utilise une imprimante. Attention, cela ne veut pas dire que seul un unique récepteur peut consulter le message, mais plutôt qu'un seul récepteur peut le consulter. Ainsi, si deux programmes se mettent en attente sur une même queue, le premier programme reçoit le premier message émis, le second progamme reçoit le second message. La structure queue peut également être utilisée vers un destinataire unique pour éviter que tous les récepteurs ayant souscrit à un topic aient la possibilité de consulter un message. C'est le cas par exemple d'une réponse vers un unique utilisateur lorsqu'on se trouve en mode topic. Il faut dans ce cas que l'émetteur initial dispose d'une queue, qu'il annonce dans son message initial en vue d'une réponse.</p>
        <p> Dans la communication événementielle, l'objet intermédiaire utilise un sujet (topic). L'émetteur publie son message sur un topic. Les récepteurs s'inscrivent au topic pour recevoir les messages publiés sur ce topic. Plusieurs publishers peuvent envoyer des messages sur le même topic et plusieurs subscribers peuvent consulter les messages du topic. C'est le cas par exemple lors d'un fil de discussion dans un <em>chat</em>. Notons que si deux programmes se mettent en attente sur un même topic, les deux programmes reçoivent le message contrairement à une structure queue.</p>

    <h3>Exemple d'une communication Topic avec JMS 1.1 :</h3>

        <p>Dans cet exemple l'émetteur publie une chaîne de caractères sur l'objet intermédiaire utilisant la structure topic. Un récepteur souscrit au topic pour lire la chaîne de caractères.</p>

        <p><em>Côté émetteur :</em></p>

<pre><code class="language-java">public class Publisher {
    public static void main(String[] args) {
		try {
			// Le detail des proprietes (url, port, ...) se trouve dans jndi.properties.
            // La creation de prop n'est nécessaire que côté serveur
	    	Properties prop = new Properties();
            // creation du contexte
            InitialContext ctx = new InitialContext();
            // creation et acces au topic
            Topic topic = (Topic) ctx.lookup("MyTopic");
            // connexion au provider, creation de l'objet intermediaire
            TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactory");
            // connexion au bus permettant le transport vers le MOM
            TopicConnection conn = factory.createTopicConnection();
            conn.start();
            // creation de session
            // false pour spécifier que les messages reçus seront traités en accord
            // avec le second paramètre Session.AUTO_ACKNOWLEDGE
            TopicSession sess = conn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

		    // creation d'un objet emetteur
	   		TopicPublisher pbr = sess.createPublisher(topic);
	    	pbr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

			// publication d'un message "hello world"
	    	TextMessage tmess = sess.createTextMessage("hello world");
	    	// possibilité de changer ultérieurement avec message.setText("hello world");
	    	pbr.publish(tmess);

	    	// fermeture de connexion
	    	conn.close();
		} catch (Exception e) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <p><em>Côté récepteur :</em></p>

<pre><code class="language-java">public class Subscriber {

    public static void main(String[] args) {
		try {
            InitialContext ctx = new InitialContext();
            Topic topic = (Topic) ctx.lookup("MyTopic");
            TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactory");
            TopicConnection conn = factory.createTopicConnection();
            conn.start();
            TopicSession sess = conn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

	    	// creation d'un objet destinataire
	    	TopicSubscriber scr = sess.createSubscriber(topic);

		    // lecture d'un message, receive est une fonction bloquante
	    	TextMessage tmess = (TextMessage) scr.receive();
	    	System.out.println("message lu : " + tmess.getText());

		    conn.close();
		} catch( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

        <p>La méthode receive() est bloquante. On peut rendre durable le récepteur en remplaçant sess.createSubscriber(topic) par sess.createDurableSubscriber(topic, nom_id). Il faudra ensuite terminer cette fonctionnalité avec sess.unsubscribe(nom_id)</p>

    <h3>Exemple d'une communication Queue avec JMS 1.1 :</h3>

      <p>Dans cet exemple un émetteur envoie un objet de type Message à l'objet intermédiaire utilisant la structure queue. Un récepteur consulte la chaîne de caractères.</p>

        <p><em>Côté émetteur</em></p>

        <pre><code class="language-java">public class Emetteur {

    public static void main(String[] args) {
		try {
	    	InitialContext ctx = new InitialContext();
            // creation et acces a la file d'attente
            Queue queue = (Queue) ctx.lookup("MyQueue");
            QueueConnectionFactory factory = (QueueConnectionFactory) ctx.lookup("MyConnectionFactory");
            QueueConnection conn = factory.createQueueConnection();
            conn.start();
            QueueSession sess = conn.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

	    	QueueSender sdr = sess.createSender(queue);
	    	sdr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

	    	Message mess = new Message("bob", new Date(), "hello world");
            ObjectMessage obj = sess.createObjectMessage(mess);
	   		sdr.send(obj);

	   		conn.close();
		} catch( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

        <p><em>Côté récepteur :</em></p>

        <pre><code class="language-java">public class Receiver {

    public static void main(String[] args) {
		try {
            Properties prop = new Properties();
	    	InitialContext ctx = new InitialContext();
            Queue queue = (Queue) ctx.lookup("MyQueue");
            QueueConnectionFactory factory = (QueueConnectionFactory) ctx.lookup("MyConnectionFactory");
            QueueConnection conn = factory.createQueueConnection();
            conn.start();
            QueueSession sess = conn.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

	    	QueueReceiver rcv = sess.createReceiver(queue);

	    	ObjectMessage obj = (ObjectMessage) rcv.receive();
            Message mess = (Message) obj.getObject();
		    System.out.println("message reçu: " + mess.toString());

	    	conn.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
    }
}</code></pre>

        <p>La classe Message doit être présente à la fois côté serveur et côté client. Comme l'objet doit être transmis, la classe Message implémente l'interface Serializable.</p>

        <pre><code class="language-java">public class Message implements Serializable{
    String nom;
    Date date;
    String contenu;

    public Message(String nom, Date date, String contenu){
        this.nom = nom;
        this.date = date;
        this.contenu = contenu;
    }

    @Override
    public String toString(){
        System.out,print("nom: "+nom+",date: "+date+", contenu: "+contenu);
    }
}</code></pre>

    <h3>Exemple d'un échange sur un Topic avec JMS 1.1 :</h3>

        <p>Dans cet exemple, un serveur publie sur l'objet intermédiaire une chaîne de caractères et consulte une chaîne de caractères publiée en réponse par un client. L'échange se fait au sein d'une unique session.</p>

    <p><em>Côté serveur</em></p>

    <pre><code class="language-java">public class Serveur {
	public static void main(String[] args) {
		try {
            Properties prop = new Properties();
	    	InitialContext ctx = new InitialContext();
            Topic topic = (Topic) ctx.lookup("MyTopic");
            TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactory");
            TopicConnection conn = factory.createTopicConnection();
            conn.start();
            TopicSession sess = conn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

            // envoi d'un message
	    	TopicPublisher pbr = sess.createPublisher(topic);
	    	pbr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
            TextMessage tmess = sess.createTextMessage("hello");
	    	pbr.publish(tmess);

	    	// attente que le destinataire reçoive le message
	    	Thread.sleep( 5000 );

	    	// reception d'un message reponse
            TopicSubscriber sbr = sess.createSubscriber(topic);
	    	TextMessage treponse = (TextMessage) sbr.receive();
	    	System.out.println(treponse.getText());

	    	conn.close();
		} catch ( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <p><em>Côté client</em></p>

    <pre><code class="language-java">public class Client {

    public static void main(String[] args) {
		try {
	    	InitialContext ctx = new InitialContext();
            Topic topic = (Topic) ctx.lookup("MyTopic");
            TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactory");
            TopicConnection conn = factory.createTopicConnection();
            conn.start();
            TopicSession sess = conn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

	    	// lecture d'un message
	    	TopicSubscriber sbr = sess.createSubscriber(topic);
            TextMessage tmess = (TextMessage) sbr.receive();
	    	System.out.print(tmess.getText());

	    	// envoi d'un message reponse
            TopicPublisher pbr = sess.createPublisher(topic);
	    	pbr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
	    	TextMessage treponse = sess.createTextMessage("world");
	    	pbr.send(treponse);

	    	conn.close();
		} catch (Exception e) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

        <h3>Exemple de communication topic avec réponse ciblée en JMS1.1 :</h3>

        <p>Dans cet exemple un serveur publie une chaîne de caractères sur un topic, et un client répond en envoyant une chaîne de caractères sur une queue, pour que seul le serveur puisse le consulter. Le serveur doit donc dans ce cas envoyer sur le topic un objet contenant la chaîne de caractères et la référence du queue à laquelle est connectée le serveur.</p>

        <p><em>Côté serveur :</em></p>

<pre><code class="language-java">public class Serveur{
  public static void main(Strings[] args){
    try{
      Properties prop = new Properties();
      InitialContext ctx = new InitialContext();
      Topic topic = (Topic) ctx.lookup("MyTopic");
      TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactoy");
      TopicConnection connT = factory.createTopicConnection();
      connT.start();
      TopicSession sessT = connT.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

      TopicPublisher pbr = sessT.createPublisher(topic);
      pbr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
      TextMessage tmess = sess.createTextMessage("hello");
      pbr.publish(tmess);

      Queue queue = (Queue) ctx.lookup("MyQueue"):
      QueueConnectionFactory queue = (QueueConnectionFactory) ctx.lookup("MyConnectionfactory");
      QueueConnection connQ = queue.createQueueConnection();
      connQ.start();
      QueueSession sessQ = connQ.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

      QueueReceiver rcv = sessQ.createReceiver(queue);
      TextMessage tmess = (TextMessage) rcv.receive();

      connT.close();
      connQ.close();
    }catch (Exception e){
      e.printStackTrace();
    }
  }
}</code></pre>

        <p><em>Côté client concerné par la réponse, les autres clients n'ont pas connaissance du code queue:</em></p>

        <pre><code class="language-java">public class Client{
  public static void main(String[] args){
     try{
        InitialContext ctx = new InitialContext();
        Topic topic = (Topic) ctx.lookup("MyTopic");
        TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactoy");
        TopicConnection connT = factory.createTopicConnection();
        connT.start();
        TopicSession sessT = connT.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

        TopicSubscriber sbr = sess.createSubscriber(topic);
        TextMessage tmess = (TextMessage) sbr.receive();

        Queue queue = (Queue) ctx.lookup("MyQueue"):
        QueueConnectionFactory queue = (QueueConnectionFactory) ctx.lookup("MyConnectionfactory");
        QueueConnection connQ = queue.createQueueConnection();
        connQ.start();
        QueueSession sessQ = connQ.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

        QueueSender sdr = sessQ.createSender(queue);
        sdr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
        TextMessage tmess = sessQ.createTextMessage("world");
        sdr.send(tmess);

        connT.close();
        connQ.close();
     }catch (Exception e){
      e.printStackTrace();
    }
  }
}</code></pre>

        <p>Il est possible de créer un Listener chez le serveur, qui attend un message pour suivre des instructions.</p>

        <pre><code class="language-java">AlertListener al = new AlertListener();
pbr.setMessageListener(al);</code></pre>

        <pre><code class="language-java">public class AlertListener implements MessageListener{
    public void onMessage(Message mess){
        try{
            System.out.print("Alerte:"+(TextMessage)mess.getText());
        catch(JMSException e){
            e.printStackTrace();
        }
    }
}</code></pre>

    </div>



    <!-- Les services Web -------------------------------------------------->

    <h2 id="servicesweb">Le service Web REST</h2>



    <div class="pcle"><strong>sérialisation</strong> : codage d'une information sous fome de suite de données atomiques.</br>
    <strong>parser un fichier</strong> : analyser un fichier afin d'en retirer les informations utiles.</br>
        <strong>serveur d'applications</strong> : logiciel d'infrastructure offrant un contexte d'exécution pour des applications Web et non pas de simples procédures ou scripts.</br>
        <strong>verbe HTTP</strong> : méthodes HTTP GET, POST, PUT, DELETE, ...</br>
        <strong>POJO Plain Old Java Object </strong> : objet Java lié à aucune restriction autre que celles de la spécification du langage Java. Un POJO n'étend pas de classe pré-définie, n'implémente pas d'interface et ne contient pas d'annotation pré-spécifiée @...</br>
        <strong>Servlet </strong> : classe Java qui permet de créer dynamiquement des données au sein d'un serveur HTTP. Ces données sont présentées au format HTML ou XML.</div>

    <p>Les services Web sont un ensemble de technologies permettant l'invocation de méthodes distantes. La communication et l'échange de données sont basés sur les standards Web HTTP et XML. SOAP et REST sont 2 solutions permettant à un client d'accéder aux services Web.</p>

    <p>Les principaux avantages des services Web sont les suivants :</p>
    <ul>
        <li>portabilité entre différents langages, différents systèmes d'exploitation</li>
        <li>utilisation de standards et protocoles ouverts</li>
        <li>utilisation des formats XML dans les échanges de données</li>
        <li>flexibilité, extensibilité</li>
    </ul>

    <h3>SOAP Simple Object Access Protocol</h3>

    <p>SOAP est un protocole de RPC Remote Procedure Call orienté objet et basé sur l'échange de données structurées en XML. SOAP permet l'appel de méthodes distantes dans un environnement distribué.</p>
    <p>Un message SOAP est un document XML composé d'une <em>envelope</em> avec un <em>header</em> et le <em>body</em>, corps du message. Dans le cas de l'envoi d'une image, on peut utiliser un message SOAP avec attachement en utilisant un message MIME Multimedia Internet Mail Extension.</p>

    <p>L'architecture des services SOAP se base sur les protocoles suivants :</p>
    <ul>
        <li>un protocole de transfert HTTP ou SMTP, les données échangées sont représentées en XML</li>
        <li>un protocole de description des services et méthodes WSDL</li>
        <li>un protocole de localisation des services UDDI, facultatif</li>
    </ul>

    <p>WSDL Web Service Description Langage donne la description au format XML des services Web en précisant les méthodes pouvant être invoquées. Le client a besoin de cette description détaillée des services Web avant de pouvoir les utiliser.</p>

    <p>UDDI Universal Description Discovery and Integration est un annuaire des services publiés par les providers. Une entrée du répertoire UDDI est constituée d'un fichier XML.</p>

    <p><em>Exemple de requête SOAP :</em></p>

    <pre><code class="language-java">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

&lt?xml version="1.0" encoding="utf-8"?&gt
&ltsoap:Envelope xmlns:soap="http://www.w3.org/2001/soap/envelope"&gt
&ltsoap:Body&gt
    &ltm:GetPrice xmlns:m="http://www.w3schools.com/prices"&gt
        &ltm:Item&gtApples&lt/m:Item&gt
    &lt/m:GetPrice&gt
&lt/soap:Body&gt
&lt/soap:Envelope&gt</code></pre>

    <p><em>Réponse SOAP :</em></p>

    <pre><code class="language-java">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

&lt?xml version="1.0" encoding="utf-8"?&gt
&ltsoap:Envelope xmlns:soap="http://www.w3.org/2001/soap/envelope"&gt
&ltsoap:Body&gt
    &ltm:GetPriceResponse xmlns:m="http://www.w3schools.com/prices"&gt
        &ltm:Price&gt2.59&lt/m:Price&gt
    &lt/m:GetPriceResponse&gt
&lt/soap:Body&gt
&lt/soap:Envelope&gt</code></pre>

    <h3>Développement d'un service Web SOAP avec JAX-WS</h3>

    <p>JAX-WS est intégré dans Java pour développer des services Web.</p>
    <p>Le développement d'un service Web SOAP avec JAX-WS se fait en plusieurs étapes :</p>
    <ul>
        <li>créer une interface publique</li>
        <li>implémenter l'interface</li>
        <li>publier et déployer l'application localement</li>
    </ul>

        <p>Les fichiers côté client sont créés lors de la génération du stub</p>
        <p> le fichier main du client : voir cours</p>
    <pre><code class="language-java">// interface publique
import javax.jws.*;
import javax.jws.soap.*;

@WebService
@SOAPBinding(style = Style.RCP)
public interface HelloWorld {
    String getHelloWorldAsString(String nom);
}</code></pre>

    <pre><code class="language-java">// implémentation de l'interface
        // voici mon contrat WSDL
import javax.jws.*;

@WebService(endpointInterface = "ws.HelloWorld")
public class HelloWorldImpl implements HelloWorld {

    @Overrride
    public String getHelloWorldAsString(String nom) {
        return "Hello World JAX-WS "+nom;
    }
}</code></pre>

<pre><code class="language-java">// publication de l'application et déploiement
    // j'ai exécuté la requête et je retourne le résultat
import javax.xml.ws.*;

public class HelleWorldPublisher {
    public static void main(String[] args) {
        Endpoint.publish("http://localhost:9999/ws/hello", new HelloWorldIml());
    }
}</code></pre>

    <h3>REST REpresentational State Transfer</h3>

    <p>REST utilise le protocole HTTP pour transférer les données qui sont identifiées par des URI Uniform Resource Identifier. Les requêtes du protocole HTTP sont composées d'une ligne de commande, d'une entête et d'un corps de message. Le format de stockage des données est principalement JSON JavaScript Object Notation, mais également XML.</p>

        <p>Les URI regroupent 2 sous-types d'identificateurs, les URN Uniform Resource Name et les URL Uniform Resource Locator. Les URL comprennent les chemins d'accès aux ressources accessibles. Par exemple http://domaine/chemin et mailto: adresseMail@gmail.com sont des URL. Les URN permettent de définir une identification unique et persistance pour une ressource. Par exemple l'adresse MAC d'une ordinateur, la référence ISBN:0-233-988897-2 d'un livre sont des URN.</p>

    <p>Les principales caractéristiques des services REST sont les suivantes :</p>
    <ul>
        <li>identification des données via des URI</li>
        <li>manipulation des données avec uniquement 4 opérations CRUD : Create avec la méthode @POST, Read avec la méthode @GET, Update avec la méthode @PUT et Delete avec la méthode @DELETE</li>
    </ul>

    <p>Plusieurs frameworks aident au développement des Web services REST en prenant en charge l'analyse et le traitement des requêtes côté serveur et des réponses côté client, comme par exemple Spring ou Jersey qui est intégré dans Java EE. L'interface Java pour implémenter des services Web REST s'appelle JAX-RS. Il s'agit d'un Servlet basé sur des POJO et contenant des annotations @Path, @GET, @Produces qui complètent l'objet pour en faire un objet invocable à distance à travers une méthode HTTP et accessible par un URI. L'annotation @Path permet d'indiquer que l'objet doit être exposé comme un service répondant à des requêtes REST.</p>

    <p>Les services Web REST sont généralement déployés dans les serveurs d'application comme Tomcat et JBoss.</p>

        <p>Le service Web de type REST est plus souple que le type SOAP qui est maintenant désué. REST est une API dans lequel on ne trouve pas de contrat comme pour RMI ou SOAP.</p>

        <p><em>Exemple de format JSON :</em></p>

<pre><code class="language-JSON">{
    'prenom': 'Stephane',
    'nom': 'Dupret',
    'age': 35,
    'adresse': {
        'rue': '12 bd de la libération',
        'ville': 'Marseille',
        'codePostal': '13013'
    },
    'numerosTph': [
        {
        'type': 'domicile',
        'nmr': '01234567889'
        },
        {
        'type': 'bureau',
        'nmr': '0198765432'
        }
    ]
}</code></pre>

    <p>Exemple d'utilisation de JSON avec le package Gson</p>

    <pre><code class="language-java">import com.google.gson.Gson
Gson gson = new Gson();
MyInData mid = new MyInData(45, 0.1, "hello");
String toJsonString = gson.toJson(mid);

MyInData fromJsonString = gson.froJson(jsonString, MyInData.class);</code></pre>

<h3>Exemple de communication avec un service REST :</h3>

        <p>Dans l'exemple ci-dessous, un serveur gère un service de contacts. REST ne nécessite pas de programmation côté client mais fonctionne avec un navigateur, dans lequel il convient de fournir les adresses correctes pour satisfaire les différentes requêtes. Le code au niveau du Servlet JAX-RS est le suivant :</p>

        <img src="images/rest.png">

<pre><code class="language-java">import javax.xml.bind.annotation.*;

@XmlRootElement  // les objets de type Contact doivent etre serialises en XML
public class Contact {
    int id;
    String nom;
    String email;

    public Contact(int id, String nom, String email) {
        this.id = id;
        this.nom = nom;
        this.email = email;
    }

    @Override
    public String toString() {
        return "id :" + id + ", name : " + name + ", email : " + email;
    }
}</code></pre>

        <p><em>La classe ContactBookResource</em> permet de gérer les requêtes avec la liste des contacts.</p>

<pre><code class="language-java">import java.util.*;
import javax.ws.rs.*;
import javax.ws.rs.core.*;
import javax.ws.rs.core.Response.*;

@Path("/DossierContact") // donné comme référence dans l'uri, ne correspond pas forcément au nom du dossier courant
public class ContactBookResource {
    ContactDAO dao = new ContactDAO();

    @GET
    // produit des fichiers JSON dans le cas général d'une requête, peut également produire du XML
    @Produces(MediaType.APPLICATION_JSON) // {  , MediaType.APPLICATION_XML})
    public Response  getListeContact() {
        return Response.status(Response.Status.OK).entity(dao.getListeContact()).build();
    }

    @GET
    // Dans le cas particulier d'une requete avec id, on obtient les informations du contact a partir de son id
    @Path("{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getContact(@PathParam("id") int id) {
        Contact c = dao.getContact(id);
        if (c == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        } else {
            return Response.status(Response.Status.OK).entity(c).build();
        }
    }

    @POST
    // on ajoute un contact sous forme JSON
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response setContact(Contact c) {
        Contact originalContact = dao.getContact(c.id);
        if (originalContact != null) {
            return Response.status(Response.Status.CONFLICT).build();
        } else {
            dao.setContact(c);
            return Response.status(Response.Status.OK).entity(c).build();
        }
    }

    @PUT
    // le contact est modifie a partir de son id
    @Path("{id}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response updateContact(@PathParam("id") int ident, Contact c) {
        Contact originalContact = dao.getContact(c.ident);
        if (originalContact == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        } else {
            c.id = ident;
            dao.updateContact(ident, c);
            return Response.status(Status.OK).entity(c).build();
        }
    }

    @DELETE
    // le contact est efface par rapport a son id
    @Path("{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response deleteContact(@PathParam("id") int id) {
        Contact originalContact = dao.getContact(id);
        if (originalContact == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        } else {
            dao.deleteContact(id);
            return Response.status(Status.OK).entity(originalContact).build();
        }
    }
}</code></pre>

        <p>Pour des raisons de commodité la liste des contacts est structurées en dictionnaire. Une structure de type liste n'aurait pas permis de conserver l'identité d'un contact à la suite de changements. En effet, suite à des changements, les éléments d'une liste sont bougés et leur index varie. Ce n'est pas le cas pour un dictionnaire auquel on rajoute un champ index. La classe ContactDAO permet de gérer cette liste de contacts.</p>

<pre><code class="language-java">import java.util.*;

public class ContactDAO { // DAO pour Data Access Object
    public HashMap&ltInteger, Contact&gt tableContact = new HashMap&ltInteger, Contact&gt();

    public ContactDAO() {
        Contact c1 = new Contact(0, "user1", "user1@domaine.org");
        Contact c2 = new Contact(1, "user2", "user2@domaine.org");

        tableContact.clear();
        tableContact.put(c1.id, c1);
        tableContact.put(c2.id, c2);
    }

    public ArrayList&ltContact&gt getListeContact() {
        return new ArrayList&ltContact&gt(tableContact.values());
    }

    public Contact getContact(int id) {
        return tableContact.get(id);
    }

    public void setContact(Contact c) {
        tableContact.put(c.id, c);
    }

    public void updateContact(int id, Contact c) {
        tableContact.put(id, c);
    }

    public void deleteContact(int id) {
        tableContact.remove(id);
    }
}</code></pre>

        <p>La configuration du serveur se fait grâce à la classe <em>ServletHolder</em>. La classe <em>ServletContextHandler</em> permet la gestion des principales fonctionnalités.</p>

<pre><code class="language-java">import java.util.logging.*;
import org.eclipse.jetty.server.*;
import org.eclipse.jetty.servlet.*;
import org.glassfish.jersey.servlet.*;

public class JettyServer {
    public static void main(String[] args) {
        Server srv = new Server(8080);

        // gestionnaire d'événements sur le serveur et des principales fonctionnalités
        ServletContextHandler ctx = new ServletContextHandler(ServletContextHandler.NO_SESSIONS);
        ctx.setContextPath("/"); // racine du serveur
        srv.setHandler(ctx);

        // configuration du serveur
        ServletHolder hld = ctx.addServlet(ServletContainer.class, "/rest/*");
        hld.setInitOrder(1);
        // chemin pour import de packages
        hld.setInitParameter("jersey.config.srv.provider.packages", "fr.rest");

        try {
            srv.start();
            System.out.println("Services deployed on URL = http://localhost:8080/rest/mescontacts");
            srv.join(); // gestion de threads sur Jetty
        } catch (Exception ex) {
            e.getStackTrace();
        } finally {
            srv.destroy();
        }
    }
}</code></pre>

        <p>Pour consulter les données sur le serveur, les URI pour interrogation des services sont les suivantes. On tient compte uniquement du format JSON, les instructions sont données au terminal côté client :</p>
        <ul>
            <li>pour consulter la table des contacts : </br>
                curl -H "Accept: application/json" -H "Content-Type: application/json" -X GET http://&ltserver&gt/rest/dossiercontact</li>
            <li>pour consulter le contact n°3 : </br>
                curl -H "Accept: application/json" -H "Content-Type: application/json" -X GET http://&ltserver&gt/rest/dossiercontact/3</li>
            <li>pour rajouter le contact composé de 5,tom,tom@gmail.com : </br>
                curl -H "Accept: application/json" -H "Content-Type: application/json" -X POST -d "{'id':5,'nom':'tom','email':'tom@gmail.com'}" http://&ltserver&gt/rest/dossiercontact</li>
            <li>pour mettre à jour le contact n°5 : </br>
                curl -H "Accept: application/json" -H "Content-Type: application/json" -X PUT -d "{'id':5,'nom':'tom','email':'tom12@gmail.com'}" http://&ltserver&gt/rest/dossiercontact/5</li>
            <li>pour supprimer le contact n°3 : </br>
                curl -H "Accept: application/json" -H "Content-Type: application/json" -X DELETE http://&ltserver&gt/rest/dossiercontact/3</li>
        </ul>

    <p><em>Les principaux codes statut de réponse : </em></p>
        <ul>
            <li>200 OK : tout s'est bien passé</li>
            <li>201 Created : la création de la ressource s'est bien passée</li>
            <li>204 No content : tout s'est bien passé mais le contenu de la ressource n'est pas renvoyé en réponse</li>
            <li>304 Not modified : le contenu n'a pas été modifié</li>
            <li>400 Bad request : la demande n'a pas pu être traitée correctement</li>
            <li>401 Unauthorized : l'authentification a échoué</li>
            <li>404 Not found : la ressource n'existe pas</li>
            <li>405 Method not allowed : la méthode HTTP utilisée n'est pas traitable par l'API</li>
            <li>406 Not acceptable : l'API n'est pas capable de fournir le format demandé</li>
            <li>500 Server error : le serveur a rencontré un problème</li>
        </ul>

         </div>

</section>

<footer>
    Stephane Robin
</footer>

</body>
</html>
