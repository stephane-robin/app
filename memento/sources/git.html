<!DOCTYPE HTML>
<html>

<head>
  <title> Memento </title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="prism.css">
  <meta charset="utf-8">
</head>

<!-- script de gestion des couleurs de code -->
<script defer src="prism.js"></script>

<body>

<div id="bandeau">
  <h1> Memento </h1>
  <h1> Linux </h1>

  <nav>
    <div class="element"> <a href="html.html">HTML</a> </div>
    <div class="element"> <a href="css.html">CSS</a> </div>
    <div class="element"> <a href="javascript.html">JAVASCRIPT</a> </div>
    <div class="element"> <a href="java.html">JAVA</a> </div>
    <div class="element"> <a href="kotlin.html">KOTLIN</a> </div>
    <div class="element"> <a href="android.html">ANDROID</a> </div>
    <div class="element"> <a href="php.html">PHP</a> </div>
    <div class="element"> <a href="python.html">PYTHON</a> </div>
    <div class="element"> <a href="c.html">C</a> </div>
    <div class="element"> <a href="git.html">LINUX</a> </div>
  </nav>
</div>


<aside>
  <nav id="table_matiere">
    <a href="#structureLinux">Structure du système Linux</a>
    <a href="#inviteCommande">L'invite de commande</a>
    <a href="#commande">Lignes de commande Linux</a>
    <a href="#affichageConsole">Affichage dans la console</a>
    <a href="#zip">Archive .zip</a>
    <a href="#gz">Archive .gz</a>
    <a href="#bash">Installation avec .sh</a>
    <a href="#targz">Installation avec .tar.gz</a>
    <a href="#tarbz2">Installation avec .tar.bz2</a>
    <a href="#deb">Installation avec .deb</a>
    <a href="#upgrade">Mise à niveau</a>
    <a href="#bootable">Clé bootable</a>
    <a href="#configGit">Configuration Git</a>
    <a href="#instructionGit">Instructions Git</a>
    <a href="#historique">L'historique Git'</a>
    <a href="#branche">Les branches Git</a>
    <a href="#gitignore">.gitignore</a>
  </nav>
</aside>


<section id="principal">

  <h2 id="structureLinux">Structure du système Linux</h2>

  <p>La racine est symbolisée par / en Linux.</p>

  <ul>
    <li>bin contient les fichiers exécutables de la machine,</li>
    <li>dev contient les périphériques,</li>
    <li>etc contient les fichiers de configuration,</li>
    <li>home contient les répertoires personnels de chaque utilisateur (d'où le nom de dossier home/stephane),</li>
    <li>lib contient les bibliothèques partagées par les programmes,</li>
    <li>media est un répertoire de montage pour les périphériques amovibles,</li>
    <li>opt est utilisé pour les extensions de programmes,</li>
    <li>root est le dossier dédié au superutilisateur,</li>
    <li>sbin contient les programmes système importants,</li>
    <li>tmp est utilisé par les programmes pour stocker des fichiers,</li>
    <li>proc contient les informations du système,</li>
    <li>usr est le dossier dans lequel seront stockés les programmes installés par l'utilisateur</li>
    <li>site-packages est le dossier dans lequel seront stockés les packages</li>
    <li>var contient les logs</li>
  </ul>

<p>Un point "." devant un fichier ou dossier indique qu'il est caché lors de l'affichage. Il n'est pas pour autant introuvable,
Linux a souhaité le cacher pour ne pas encombrer l'affichage. En revanche le point "." représente le dossier courant,
alors que le double point ".." représente le dossier parent. Le signe ~ symbolise le dossier personnel /home/stephane.</p>

  <p>nano est un éditeur de texte léger présent par défaut dans les systèmes Linux. On peut le lancer en tapant simplement nano dans l'invite de commande.
    L'enregistrement d'un fichier à partir de nano se fait directement dans le dossier personnel /home/stephane. Pour ouvrir
    monFichier à partir de nano il faut taper nano monFichier dans l'invite de commande lorsqu'on se situe dans le répertoire parent.</p>

  <p>Le .bashrc est un fichier de configuration de la console. Il se situe dans le répertoire personnel /home/stephane/</p>

  <p>L'installation d'applications sous Linux ne nécessite pas de programme d'installation, mais des paquets au format .deb qui
  contiennent à la fois les instructions d'installation et l'application elle-même. Les fichiers .deb se trouvent dans des dépôts
  et la gestion des dépendances est automatisée.</p>

  <p>Les fichiers .deb sont des versions compilées de programmes, donc sous forme binaire. Ils se basent sur les codes sources
  des programmes qui sont écrits dans le langage dans lequel ils ont été créés (Python, C, Java, ...). C'est en général la
  version compilée des sources qui nous intéresse pour procéder à l'installation d'un programme.</p>









  <h2 id="inviteComamnde">L'invite de commande</h2>

  <p>Par défaut, l'invite de commande s'ouvre dans le dossier /home/stephane. Une fois l'invite de commande ouverte, le signe $ symbolise l'utilisateur alors que le signe # symbolise le superutilisateur qui travaille donc
  en mode root. </p>

  <p>L'autocomplétion se réalise avec la touche de tabulation, la navigation dans le terminal se fait à l'aide des flèches haut et bas.</p>

  <p>Une double tabulation permet d'afficher toutes commandes dont le nom commence par les lettres écrites
  dans la console. Par exemple lorsqu'on tape da puis deux fois la touche tabulation, on obtient les choix
  dash et date.</p>

  <p><em>clean</em> ou Ctrl+l permet d'effacer le contenu de la console.</p>

  <p><em>exit</em> ou Ctrl+d permet de fermer la console</p>






  <!-- LIGNES DE COMMANDE -->

  <h2 id="commande">Les principales lignes de commande</h2>

  <h3>Se déplacer, connaître l'emplacement</h3>

  <table>
    <tr> <th> Objectif</th> <th> Instruction</th> </tr>
    <tr> <td> afficher le dossier courant (print working directory)</td><td><pre>pwd</pre></td></tr>
    <tr> <td> connaître l'emplacement d'un programme (par exemple Python)</td> <td><pre>which python</pre></td></tr>
    <tr> <td> se rendre dans le dossier <em>Documents</em> </td> <td> <pre>cd Documents</pre> </td> </tr>
    <tr> <td> revenir au dossier parent </td> <td> <pre>cd ..</pre></td> </tr>
    <tr> <td> revenir à /home/stephane </td> <td> <pre>cd</pre></td> </tr>
    <tr> <td> afficher la date </td> <td> <pre>date</pre></td></tr>
    <tr> <td> trouver <em>monFichier</em></td> <td><pre>whereis monFichier</pre></td></tr>
  </table>


  <h3>Lister, afficher</h3>

  <table>
    <tr> <th> Objectif</th> <th> Instruction</th> </tr>
    <tr> <td> afficher la liste des éléments du dossier courant </td> <td> <pre>ls</pre></td> </tr>
    <tr> <td> afficher la liste détaillée des éléments du dossier courant </td> <td> <pre>ls -l</pre></td> </tr>
    <tr> <td> afficher la liste détaillée des éléments du dossier courant avec une taille facilement lisible pour
      l'homme</td> <td><pre>ls -lh</pre></td></tr>
    <tr> <td> afficher la liste des éléments du dossier courant avec les éléments cachés </td> <td> <pre>ls -a</pre></td> </tr>
    <tr> <td> afficher la liste détaillée des éléments du dossier courant avec les éléments cachés </td> <td> <pre>ls -la</pre></td> </tr>
    <tr> <td> afficher la liste détaillée des éléments du dossier courant en triant par date de dernière modification au lieu de trier par ordre alphabétique</td> <td><pre>ls -lt</pre></td></tr>
    <tr> <td> afficher la liste des éléments de MonDossier</td> <td><pre>ls ~/Documents/MonDossier</pre></td></tr>
    <tr> <td> afficher la liste des éléments actifs du dossier local </td> <td> <pre>ps</pre></td> </tr>
    <tr> <td> afficher le contenu de <em>monFichier</em> (voir détails plus bas)</td> <td> <pre>cat monFichier</pre></td> </tr>
  </table>

  <h3>Créer, copier, déplacer, supprimer</h3>

  <p>Attention, il n'y a pas de possibilité de récupération d'un dossier ou fichier supprimé à l'aide de la commande rm. Il n'y a
  donc pas d'équivalent d'une corbeille lorsqu'on utilise les lignes de commande. Il n'y a pas non plus de demande de confirmation, le dossier ou fichier
  est simplement supprimé au moment oû l'utilisateur presse la touche Entrée, à moins d'utiliser l'option -i. La commande rm est donc à utiliser avec précaution,
    et il semble important d'utiliser systématiquement l'option -i.</p>

  <table>
    <tr> <th> Objectif</th> <th> Instruction</th> </tr>
    <tr> <td> créer le fichier <em>monFichier</em> </td> <td> <pre>touch monFichier</pre></td> </tr>
    <tr> <td> créer le dossier <em>monDossier</em> </td> <td> <pre>mkdir monDossier</pre></td> </tr>
    <tr> <td> creer le dossier <em>monDossier</em> contenant le sous-dossier <em>monSousDossier</em></td> <td><pre>mkdir -p monDossier/monSousDossier</pre></td></tr>
    <tr> <td> supprimer <em>monFichier</em> </td> <td><pre>sudo rm monFichier</pre></td></tr>
    <tr> <td> supprimer <em>monFichier</em> en demandant confirmation (-i) et en demandant l'état de ce qui a été fait (-v)</td> <td><pre>sudo rm -vi monFichier</pre></td></tr>
    <tr> <td> supprimer <em>monDossier</em> et tout ce qu'il contient</td> <td><pre>sudo rm -r monDossier</pre></td></tr>
    <tr> <td> déplacer <em>monFichier</em></td> <td><pre>mv chemin_monFichier  chemin_nouvelEmplacement</pre></td></tr>
    <tr> <td>copier monFichier dans le répertoire courant</td> <td><pre>cp monFichier monFichierCopie</pre></td></tr>
    <tr> <td>copier monFichier dans Documents</td> <td><pre>cp monFichier ~/Documents/monFichierCopie</pre></td></tr>
    <tr> <td>copier monFichier dans Documents sous le même nom</td> <td><pre>cp monFichier ~/Documents/</pre></td></tr>
    <tr> <td> copier tous les fichiers au format .py dans monDossier</td> <td><pre>cp *.py monDossier/</pre></td></tr>
    <tr> <td> copier monDossier et tout ce qu'il contient</td> <td><pre>cp -R monDossier monDossierCopie</pre></td></tr>
    <tr> <td> déplacer monFichier dans monDossier</td> <td><pre>mv monFichier monDossier/</pre></td></tr>
    <tr> <td> déplacer monDossier et tout ce qu'il contient dans monAutreDossier</td> <td><pre>mv monDossier/ monAutreDossier/</pre></td></tr>
    <tr> <td> déplacer tous les fichiers au format .py dans monDossier</td> <td><pre>mv *.py monDossier/</pre></td></tr>
    <tr> <td> renommer monFichier en nouveauNomFichier</td> <td><pre>mv monFichier nouveauNomFichier</pre></td></tr>
    <tr> <td> déplacer monFichier dans monDossier et le renommer nouveauNomFichier</td> <td><pre>mv monFichier monDossier/nouveauNomFichier</pre></td></tr>
  </table>

  <h3>Commandes générales</h3>

  <table>
    <tr> <th> Objectif</th> <th> Instruction</th> </tr>
    <tr> <td> stopper l'exécution d'un code ou d'un serveur </td><td><pre>Ctrl+c</pre></td></tr>
    <tr> <td> quitter une interface exécutée à partir du terminal </td> <td><pre>q</pre></td></tr>
    <tr> <td> vider le terminal</td> <td> <pre>clear</pre></td> </tr>
    <tr> <td> lancer l'interpréteur Python </td> <td><pre>python</pre></td></tr>
    <tr> <td> exécuter monFichier.py </td> <td><pre>python monFichier.py</pre></td></tr>
    <tr> <td> quitter l'interpréteur Python </td> <td><pre>exit()</pre></td></tr>
    <tr> <td> installer un package Python </td> <td><pre>pip install monPackage</pre><pre>conda install monPackage</pre></td></tr>
    <tr> <td> désinstaller un package Python </td> <td><pre>pip uninstall monPackage</pre></td></tr>
    <tr> <td> exécuter monPackage en Python </td> <td><pre>python -m monPackage</pre></td></tr>
    <tr> <td> connaître la taille du dossier courant (uniquement) en utilisant une lecture facile pour l'homme</td> <td><pre>du -sh</pre></td></tr>
    <tr> <td> connaître la version du système Linux</td> <td><pre>lsb_release -a</pre></td></tr>
  </table>





<h2 id="affichageConsole">Affichage d'un fichier dans la console</h2>

  <p>Pour afficher un fichier tout entier dans la console, on se place dans le dossier parent du fichier à lire puis on utilise l'instruction</p>
  <pre><code class="language-svg">cat nomFichier</code></pre>

  <p>Si l'on souhaite afficher également le numéro de chaque ligne du fichier il faut rajouter</p>
  <pre><code class="language-svg">cat nomFichier -n</code></pre>

  <p>Si l'on souhaite afficher le fichier page par page, on utilise l'instruction</p>
  <pre><code class="language-svg">less nomFichier</code></pre>

  <p>Dans ce cas, la console ne fonctionne plus qu'en mode affichage.</p>
  <ul>
    <li>pour revenir en mode normal, il faut taper 'q'</li>
    <li>pour descendre d'une ligne, on peut utiliser la flèche du bas</li>
    <li>pour monter d'une ligne, on peut utiliser la flèche du haut</li>
    <li>pour descendre en bas de l'ếcran, on peut utiliser la touche Entrée ou la touche Page Down</li>
    <li>pour monter en haut de l'écran, on peut utiliser la touche Page Up</li>
    <li>pour rechercher unMot dans le fichier lu dans la console, on peut utiliser /unMot directement</li>
  </ul>

  <p>Pour afficher les 5 premières lignes de monFichier</p>
  <pre><code class="language-svg">head -n 5 monFichier</code></pre>




  <h2>RTFM</h2>

  <p> Pour afficher la documentation relative à la commande mkdir dans la console, on utilise </p>
  <pre><code class="language-svg">man mkdir</code></pre>

  <p>La documentation contient les éléments suivants :</p>
  <ul>
    <li>NAME : le nom de la commande</li>
    <li>SYNOPSIS : les différentes formes d'utilisation de la commande</li>
    <li>DESCRIPTION : détail des différentes options possibles et explications des fonctionnalités</li>
    <li>AUTHOR : auteurs de la documentation et de la commande</li>
    <li>REPORTING BUGS : adresses pour reporter un bug</li>
    <li>COPYRIGHT : licence d'utilisation</li>
    <li>SEE ALSO : autres commandes pouvant être utiles</li>
  </ul>




  <!-- DROITS UTILISATEUR -->

  <h2>Les droits d'utilisateur</h2>

  <p>La commande <em>sudo</em> permet de passer temporairement en mode root et d'acquérir les droits du super-utilisateur. Elle signifie
    Substitute User DO. Une fois en mode root, l'invite de commande se termine par le symbole # .</p>
  <p>Contrairement à Windows, le système Linux n'est pas connecté par défaut en mode root, ce qui limite les risques potentiels.</p>



  <h3>Changement de mot de passe</h3>

  <p>Pour changer le mot de passe du compte stephane :</p>

  <pre><code class="language-svg">sudo passwd stephane</code></pre>

  <p>Pour changer le mot de passe du compte sur lequel on est connecté, c'est à dire du super-utilisateur et de la connexion à la machine.</p>

  <pre><code class="language-svg">sudo passwd</code></pre>


  <h3>Modification des droits d'accès</h3>

  <p>Chaque dossier et chaque fichier possède une liste de droits symbolisés par une lettre :</p>
  <ul>
    <li>d pour directory : indique si l'élément est un dossier</li>
    <li>l pour link : indique si l'élément est un lien ou un raccourci vers un fichier ou dossier</li>
    <li>r pour read : indique si on peut lire l'élément</li>
    <li>w pour write : indique si on peut modifier l'élément et donc le supprimer</li>
    <li>x pour execute : indique si on peut exécuter cet élément lorsque c'est un fichier, indique si on
      peut voir les sous-dosssiers qu'il contient lorsqu'on a le droit de lecture dessus</li>
  </ul>

  <p>On peut consulter ces droits avec la commande ls -l. Lorsqu'ils existent les droits sont symbolisés par une lettre,
    lorsqu'ils n'existent pas les droits sont remplacés par un tiret. Par ailleurs, les droits sont regroupés de la façon suivante et
    sans espace : (dossier) (utilisateur proprétaire) (groupe) (autres utilisateurs)</p>
    <p>Par exemple on peut trouver les information suivantes lorsqu'on utilise la commande ls -l</p>

  <pre><code class="language-svg">drwxr-xr-x 1 stephane stephane 4096 2020-11-03 21:37 Desktop</code></pre>

  <p>Lorsqu'un dossier autorise tous les droits, on obtient donc l'information suivante drwxrwxrwx</p>

<p>La commande chmod permet de modifier les droits d'accès d'un fichier ou d'un dossier. Attention de ne pas la confondre
  avec la commande chown qui permet de gérer quel utilisateur et quel groupe est propriétaire d'un fichier</p>

  <p>Il n'est pas nécessaire d'être super-utilisateur pour modifier un dossier ou fichier. En revanche, il faut être propriétaire de ce dossier ou fichier.</p>

  <p>Pour utiliser la commande chmod, il faut savoir qu'à chaque lettre correspond un chiffre. Ainsi, r correspond à 4,
  w correspond à 2 et x correspond à 1. On combine maintenant les droits en additionnant les chiffres précédents.</p>
  <p>Ainsi le tableau suivant récapitule les différents droits sous forme de chiffres :</p>

  <table>
    <tr><th>droits</th><th>chiffres correspondants</th></tr>
    <tr><td>---</td><td>0</td></tr>
    <tr><td>r--</td><td>4</td></tr>
    <tr><td>-w-</td><td>2</td></tr>
    <tr><td>--x</td><td>1</td></tr>
    <tr><td>rw-</td><td>6</td></tr>
    <tr><td>wx-</td><td>3</td></tr>
    <tr><td>r-x</td><td>5</td></tr>
    <tr><td>rwx</td><td>7</td></tr>
  </table>

<p>Par exemple 640 représente les droits du propriétaire (6 donc lecture, écriture), les droits du groupe (4 donc lecture),
et les droits des autres utilisateurs (0 donc aucun droit).</p>

  <p>Finalement, pour changer les droits sur le monFichier et être le seul autorisé à le lire et le modifier, il faut exécuter la commande suivante</p>
  <pre><code class="language-svg">chmod 600 monFichier</code></pre>
  <p>Cette commande est la même pour un dossier. Il faut penser à se placer dans le répertoire parent ou préciser une adresse absolue.</p>

  <p>Maintenant la commande ls -l fournit le résultat suivant</p>
  <pre><code class="language-svg">-rw------- 1 stephane stephane 0 2019-09-15 21:12 monFichier</code></pre>

  <p>Pour affecter des droits sur un dossier de manière récursive, c'est à dire en affectant tous les fichiers et sous-dossiers qu'il contient,
  il faut utiliser la commande</p>
  <pre><code class="language-svg">chmod -R 600 monFichier</code></pre>
  <p>Cette commande est la même pour un dossier. Il faut penser à se placer dans le répertoire parent ou préciser une adresse absolue.</p>




  <h2>Installation d'un programme avec apt-get</h2>

  <p>Il faut généralement mettre à jour le cache des paquets (i.e. télécharger la nouvelle liste des paquets proposés par le dépôt) avant de procéder à l'installation :</p>
  <pre><code class="language-svg">sudo apt-get update
sudo apt-get install monPaquet</code></pre>

  <p>Pour obtenir la description d'un paquet :</p>
  <pre><code class="language-svg">sudo apt-cache show nomPaquet</code></pre>

  <p>Pour désinstaller un paquet</p>
  <pre><code class="language-svg">sudo apt-get remove monPaquet</code></pre>

  <p>Pour désinstaller un paquet et ses dépendances devenues inutiles</p>
  <pre><code class="language-svg">sudo apt-get autoremove monPaquet</code></pre>

  <p>Pour mettre à jour tous les paquets, il faut d'abord récupérer la liste des nouveaux paquets afin de pouvoir comparer leurs versions
    à celles présentes dans le système. Cette opération doit être faite régulièrement pour assurer la sécurité du système.</p>
  <pre><code class="language-svg">sudo apt-get update
sudo apt-get upgrade</code></pre>

  <p>Pour nettoyer le système, il faut utiliser les instructions suivantes</p>
  <pre><code class="language-svg">sudo apt-get autoclean
sudo apt-get clean
sudo apt-get autoremove</code></pre>




  <!-- zipper un dossier zip -->

  <h2 id="zip">Commandes pour zipper/dézipper un dossier .zip</h2>

  <p>Pour zipper le dossier mon_dossier en l'appelant mon_archive.zip :</p>
  <pre><code class="language-svg">zip -r mon_archive.zip mon_dossier</code></pre>

  <p>Pour dézipper l'archive mon_archive.zip en l'appelant mon_dossier :</p>
  <pre><code class="language-svg">unzip mon_archive.zip -d mon_dossier</code></pre>



<!-- dézipper un dossier .gz-->

  <h2 id="gz">Commande pour dézipper un dossier .gz</h2>

  <p>Il faut se placer dans le dossier contenant mondossier.gz et l'instruction
    suivante va le décompresser à ce même emplacement :</p>
  <pre><code class="language-svg">gunzip mondossier.gz</code></pre>


  <!-- installation d'un logiciel avec sh -->

  <h2 id="bash">Installation d'un logiciel à partir de .sh</h2>

  <p>Un fichier au format .sh est un fichier d'installation qui s'ouvre avec une commande bash. Pour cela, dans le répertoire courant, il faut d'abord
    vérifier l'intégrité de l'installer en utilisant :</p>

  <pre><code class="language-svg">sha256sum nomInstaller.sh</code></pre>

  <p>puis lancer l'installation à l'aide de :</p>

  <pre><code class="language-svg">bash nomInstaller.sh</code></pre>

  <!-- installation d'un logiciel avec.tar.gz -->

  <h2 id="targz">Installation d'un logiciel à partir de .tar.gz</h2>

  <p>Un fichier .tar est une archive non compressée. En revanche, un fichier .gz est une compression de fichier.</p>
  <p>Il faut d'abord déplacer le fichier .tar.gz vers /usr/local. Pour cela :</p>
  <pre><code class="language-svg">sudo mv /home/stephane/Téléchargements/nom_fichier.tar.gz /usr/local</code></pre>
  <p>Il faut ensuite se placer dans le répertoire /usr/local</p>
  <pre><code class="language-svg">cd /usr/local</code></pre>
  <p>Puis il faut décompresser le fichier .gz :</p>
  <pre><code class="language-svg">sudo tar xvzf nom_fichier.tar.gz</code></pre>

  <p>Finalement, il faut suivre les instructions d'installation dans le ficier README.txt ou le INSTALL</p>



<!-- installation d'un logiciel avec tar.bz2 -->

  <h2 id="tarbz2">Installation d'un logiciel à partir de .tar.bz2</h2>

  <p>Il faut d'abord déplacer le fichier .tar.bz2 vers /usr/local. Pour cela :</p>
  <pre><code class="language-svg">sudo mv /home/stephane/Téléchargements/nom_fichier.tar.bz2 /usr/local</code></pre>
  <p>Il faut ensuite se placer dans le répertoire /usr/local</p>
  <pre><code class="language-svg">cd /usr/local</code></pre>
  <p>Puis il faut décompresser le fichier .bz2 :</p>
  <pre><code class="language-svg">sudo tar xfvj nom_fichier.tar.bz2</code></pre>

  <p>Finalement, il faut suivre les instructions d'installation dans le ficier README.txt ou le INSTALL</p>



<!-- installation d'un logiciel à partir de .deb -->

  <h2 id="deb">Installation d'un logiciel à partir de .deb</h2>

  <p>Un fichier .deb est un package permettant d'installer une application sous les systèmes Linux Debian.</p>

  <p>Il faut d'abord déplacer le fichier .tar.bz2 vers /usr/local. Pour cela :</p>
  <pre><code class="language-svg">sudo mv /home/stephane/Téléchargements/nom_fichier.tar.bz2 /usr/local</code></pre>
  <p>Il faut ensuite se placer dans le répertoire /usr/local</p>
  <pre>cd /usr/local</pre>

  <p>Puis il faut exécuter le fichier .deb</p>
  <pre><code class="language-svg">sudo dpkg -i nom_fichier.deb</code></pre>

  <!-- mise à niveau système -->

  <h2 id="upgrade">Comamndes de mise à niveau système</h2>

  <pre><code class="language-svg">sudo apt-get update
sudo apt-get upgrade
sudo apt dist-upgrade
sudo apt-get install update-manager-core
sudo do-release-upgrade
sudo apt-get update</code></pre>







  <!-- ANTIVIRUS -->

  <h2 id="clamav">Antivirus</h2>

  <p>L'antivirus ClamAv est compatible avec Linux et fonctionne en ligne de commande.</p>

  <p>L'installation est détaillée sur la page <a href="https://www.inmotionhosting.com/support/security/install-clamav-on-ubuntu/"> inmotion.hosting</a></p>

  <p>Pour lancer le scan, utiliser les instructions suivantes</p>
<pre><code class="language-svg">clamscan -r /</code></pre>

<p>Le processus de scan est assez long mais peut s'exécuter en toile de fond.</p>





  <!-- CREATION CLE BOOTABLE -->

  <h2 id="bootable">Création d'une clé bootable</h2>

  <p>Il faut d'abord télécharger l'archive .iso de la version souhaitée de Linux à l'aide d'un ordinateur tiers,
    créer une clé bootable à l'aide de l'application balenaEtcher, et placer cette archive dans la clé.
  Il est important de ne connecter qu'une seule clé à l'ordinateur.</p>

  <p>Il faut maintenant brancher la clé bootable sur l'ordinateur cible qu'on allume en ouvrant le menu boot (souvent F1 ou F2).
    Il faut ensuite configurer le démarrage sur clé USB, et on installe Linux en suivant les instructions.</p>


<!-- CREATION DEPOT GIT -->
<h2 id="depotGit">Création d'un dépôt Git</h2>

<p>On peut créer un dépôt Git vide ou clôner un dépôt distant.</p>

<p>Pour créer un dépôt Git vide, il faut créer un répertoire, se placer dans ce répertoire puis exécuter</p>
  <pre><code class="language-svg">git init</code></pre>

<p>Pour clôner un dépôt distant, il faut importer un remote repository du dépôt distant :</p>
  <pre><code class="language-svg">git remote add nomProjet https://github.com/monProjet
git clone https://github.com/monProjet</code></pre>


<!-- CONFIGURATION -->

<h2 id="configGit"> Configuration de Git</h2>

<p>Pour connaître la version du logiciel <em>git</em> : </p>
  <pre><code class="language-svg">git --version</code></pre>

<p>Pour configurer les données utilisateur de <em>git</em> :</p>
<pre><code class="language-svg">git config --global user.name "monNom"
git config --global user.email "monEmail"</code></pre>
<p>Il n'est pas recommandé de configurer les données utilisateur, mais préférable
de fournir les credentials à chaque utilisation pour des raisons de sécurité.</p>

<p>Pour activer la couleur dans la console :</p>
<pre><code class="language-svg">git config --global color.diff auto
git config --global color.status auto
git config --global color.branch auto</code></pre>





  <p>Pour vérifier la configuration enregistrée :</p>
  <pre><code class="language-svg">git config --list</code></pre>






<!-- LA GESTION DES BRANCHES -->

<h2 id="branche">La gestion des branches Git</h2>

<p>La branche master correspond à celle dans laquelle aboutissent toutes les 
modifications. Il ne faut pas réaliser les modifications sur cette branche master,
mais les réaliser sur une autre branche qu'on intègre ultérieurement à la branche master.</p>

<p>Pour connaître les branches présentes dans un projet, il faut exécuter</p>
<pre><code class="language-svg">git branch</code></pre>

<p>L'étoile qui apparaît dans la réponse marque la branche sur laquelle on travaille actuellement.</p>

<p>Pour créer la branche maBranche en local (elle ne sera pas dupliquée sur le dépôt distant)</p>
<pre><code class="language-svg">git branch maBranche</code></pre>

<p>Attention, une branche créée est toujours locale.</p>

<p>Pour changer de branche et se retrouver dans maBranche</p>
<pre><code class="language-svg">git checkout maBranche</code></pre>

<p>Attention, <strong>checkout</strong> a un double usage avec <em>Git</em>.</p>

<p>On peut également créer une branche et s'y rendre directement avec l'instruction :</p>
  <pre><code class="language-svg">git checkout -b nomBranche</code></pre>

<p>Pour fusionner les changements d'une branche avec la branche master, il faut d'abord se rendre sur la branche master :</p>
<pre><code class="language-svg">git checkout master
git merge nomBranche</code></pre>

<p>Pour supprimer une branche : </p>
  <pre><code class="language-svg">git branch -d nomBranche</code></pre>

<p>Cette suppression n'est possible que si le travail réalisé sur la branche fille a été incorporé dans la branche master, sinon <em>Git</em> interdit la suppression.</p>

<p>Pour supprimer une branche dont les modifications n'ont pas été incorporées à la branche master, parce que par exemple le travail réalisé n'est pas concluant :</p>
  <pre><code class="language-svg">git branch -D nomBranche</code></pre>







<!-- PRINCIPALES INSTRUCTIONS -->

<h2 id="instructionGit">Push / Pull</h2>

<p>La structure Git est composée de 3 zones locales :</p>
<ul>
<li>le working directory</li>
<li>l'index ou stage qui regroupe tous les fichiers modifiés qu'on souhaite 
voir apparaître dans le prochain commit</li>
<li>le dépôt local</li>
</ul>

<p>La commande add permet d'ajouter des fichiers du working directory vers l'index. La commande
commit permet d'enregistrer les modifications de l'index vers le dépôt local.
La commande push permet de mettre à jour le dépôt distant grâce au dépôt local, 
alors que la commande pull permet de récupérer l'état du dépôt distant vers le 
dépôt local afin de travailler dessus.</p>

<p>Notons que les commit sont réalisés sur la branche courante.</p>

<p>Pour ajouter un fichier local à l'index : </p>
  <pre><code class="language-svg">git add monFichier</code></pre>

<p>Pour supprimer un fichier local de l'index après l'avoir rajouté sans l'avoir commité :</p>
  <pre><code class="language-svg">git reset HEAD --nomFichier</code></pre>

<p>Pour ajouter rapidement à l'index sans distinction de fichier : </p>
  <pre><code class="language-svg">git add .</code></pre>

<p>On travaille normalement dans le repository local. Pour synchroniser le remote repository <em>master</em> avec le repository local <em>origin</em>, on commence par rajouter dans l'index chaque fichier modifié (add), on ajoute les dernières modifications dans l'historique des modifications (commit) et finalement on insère le fichier validé vers le remote repository (push) :</p>
<pre><code class="language-svg">git add .
git commit -m "monCommentaire"
git push origin master</code></pre>

<p>Notons que le -m dans le commit permet d'en modifier le message.</p>

<p>Il n'est pas nécessaire de définir le nom des fichiers concernés car tous les fichiers indexés et non validés vont être pris en compte par le commit. <em>Attention</em>, chaque étape est nécessaire. On peut toutefois regrouper les étapes du rajout à l'index et du commit :</p>
<pre><code class="language-svg">git commit -a -m "monCommentaire"
  git push origin master</code></pre>
<p>Attention, ici le <strong>-a</strong> ne correspond pas à l'instruction <strong>add</strong>, mais à la prise en compte de tous les fichiers <em>all</em>.</p>
<p>On remarque qu'un commit avec <em>Git</em> est local jusqu'à ce qu'on push ce commit sur le serveur.</p>

<p><em>Attention</em>, les fichiers modifiés mais non entrés dans l'index ne seront pas synchronisés.</p>

<p>Pour modifier le dernier message du commit (dans le cas par exemple où une erreur s'est glissée) :</p>
  <pre><code class="language-svg">git commit --amend -m "nouveau message de commit"</code></pre>

<p>Pour rajouter un fichier oublié alors que le commit a déjè été réalisé, sans modifier le message du commit</p>
<pre><code class="language-svg">git add fichierOublie.txt
git commit --amend --no-edit</code></pre>

<p>Pour récupérer un fichier de travail :</p>
  <pre><code class="language-svg">git pull monFichier master</code></pre>

<p>Ou de façon plus générale :</p>
  <pre><code class="language-svg">git pull origin master</code></pre>
<p>Dans ce cas, origin correspond au remote repository.</p>

<p>Il est possible à tout moment de voir l'état des fichiers (ceux qui ont été modifiés 
mais pas encore committés par exemple) en exécutant</p>
<pre><code class="language-svg">git status</code></pre>





<!-- L'HISTORIQUE -->

<h2 id="historique">L'historique Git</h2>

<p>Pour consulter l'historique (les <em>logs</em>) :</p>
  <pre><code class="language-svg">git log</code></pre>

<p>Pour obtenir l'historique et le détail des lignes retirées et rajoutées :</p>
  <pre><code class="language-svg">git log -p</code></pre>

<p>Pour quitter la liste des <em>logs</em>, il faut taper Q.</p>

<p>On peut se positionner à un moment de l'historique en ne tenant compte que des commit enregistrés jusqu'à un commit défini. On utilise alors <strong>git checkout codeCommit</strong> oû <em>codeCommit</em> est le code sha présent dans le log et représentatif d'un unique commit. A partir de cette requête, <strong>git log</strong> n'affiche que les commit enregistrés jusqu'au commit <em>codeCommit</em>. Pour revenir à l'état du dernier commit, on utilise l'instruction <strong>git checkout master</strong>.

<p>Pour consulter les modifications :</p>
  <pre><code class="language">git diff</code></pre>
<p>Les ligness ajoutées sont précédées d'un + et affichées en vert, tandis que les lignes supprimées sont précédées d'un - et affichées en rouge.</p>

<p>Pour consulter les modifications d'un seul fichier :</p>
  <pre><code class="language-svg">git diff monFichier</code></pre>

<p>A noter que <em>GitHub</em> propose un affichage des modifications d'un commit plus convivial que le Terminal. Il s'agit dans ce cas des commits envoyés au remote.</p>

<p>Pour annuler les modifications d'un fichier avant un commit, et restaurer le fichier tel qu'il était au dernier commit :</p>
  <pre><code class="language-svg">git checkout nomFichier</code></pre>

<p>Pour annuler le dernier commit et revenir à l'avant dernier : </p>
  <pre><code class="language-svg">git reset HEAD^</code></pre>

<p>Pour annuler un numéro de commit précis : </p>
  <pre><code class="language-svg">git reset nrmCommit </code></pre>
<p>Dans ce cas seul le commit est retiré de <em>Git</em>, les fichiers restent modifiés.</p>

<p>Pour annuler le dernier commit et les changements effectués dans les fichiers :</p>
  <pre><code class="language-svg">git reset --hard HEAD^</code></pre>
<p>Attention, dans ce cas tous les changements sont perdus sans préavis.</p>

<p>Dans le cas où des commits ont été faits simultanément par plusieurs postes dans un même projet, les modifications sont incorporées automatiquement. Dans le cas où deux changement concernent la même zode de code, un conflit apparaît qui doit être résolu manuellement en travaillant sur la zone de code marquée <<<<<<<<<<<<< . Sur <em>GitHub</em>, la résolution de conflit ne pourra être faite que par la personne déclarée responsable de projet.</p>

<p>Attention, un push est en revanche irréversible. Il est donc recommandé de faire régulièrement des commit, mais de faire un push qu'une fois par jour, sinon on perd la facilité avec laquelle il est possible d'annuler ou de modifier les commit.</p>

<p>Il reste toutefois possible d'annuler un commit déjà pushé en créant un nouveau commit qui effectue l'inverse des modifications. On ne peut en effet pas réellement supprimer un commit.</p>
  <pre><code class="language-svg">git revert nrmCommit</code></pre>

<p>Pour donner un tag à un commit afin de le retrouver sous une référence particulière, comme une version par exemple :</p>
<pre><code class="language-svg">git tag nomTag nmrCommit
  git push --tags</code></pre>

<p>Attention, cette instruction spécifique <strong>--tags</strong> est importante car autrement un tag n'est pas envoyé lors d'un push.</p>

<p>Pour supprimer un tag :</p>
  <pre><code class="language-svg">git tag -d nomTag</code></pre>

<p>Pour retrouver qui a modifié une ligne précise de code dans un projet :</p>
  <pre><code class="language-svg">git blame nomFichier</code></pre>
<p>On obtient ainsi toutes les modifications faites sur un fichier ligne par ligne avec le début du <em>sha</em> du commit correspondant. Il faut alors utiliser l'instruction suivante pour consulter les détail du commit recherché :</p>
  <pre><code class="language-svg">git show nrmCommit</code></pre>








<!-- IGNORER DES FICHIERS -->

<h2 id="gitignore">Ignorer des fichiers avec gitignore</h2>

<p>Il ne faut jamais versionner une variable de configuration, comme par exemple un mot de passe ou une clé secrète. Si le code a déjà été envoyé sur <em>GitHub</em>, il convient de changer de mot de passe ou générer une nouvelle clé secrète.</p>

  <p>Il est important d'ignorer certains fichiers dans <em>Git</em>, tels que :</p>
  <ul>
    <li>les fichiers de configuration (config.xml, database.yml)</li>
    <li>les fichiers temporaires (tml, temp)</li>
    <li>les fichiers créés par l'IDLE ou l'OS (.DS_Store)</li>
  </ul>
<p>Ainsi, les variables de configuration devront être déplacées dans un fichier de configuration et ignorées dans <em>Git</em>.</p>

<p>Il faut créer un fichier <em>.gitignore</em> et placer dans ce fichier le nom de tous les fichiers qui devront être ignorés par le versionnement.</p>
  <pre><code class="language-svg">touch .gitignore</code></pre>

<p>Pour écrire dans ce fichier <em>.gitignore</em>, il faut ouvrir l'éditeur de terminal <em>vim</em> :</p>
  <pre><code class="language-svg">vim .gitignore</code></pre>

<p>Pour sortir de <em>vim</em> :</p>
  <pre><code class="language-svg">:q</code></pre>




</section>

<footer>
</footer>

</body>
</html>
