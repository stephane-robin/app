<h2>Les variables</h2>




    <!------------- LES TABLEAUX ----------------------------->

    <h3>Les tableaux</h3>



        <p>Les tableaux sont des éléments de stockage statiques, dont la taille ne doit pas varier. Ainsi, on ne peut pas rajouter d'élément à un tableau sous peine d'en modifier totalement la structure. Les tableaux sont indexés à partir de 0 et n'admettent pas de système clé-valeur.</p>

        <pre><code class="language-java">import java.util.*;</code></pre>

        <h4>Déclaration d'un tableau</h4>

        <p>Un tableau doit être déclaré en indiquant le type d'objet qu'il contient. Il ne peut pas contenir des objets de types différents. Toutefois, on peut facilement déroger à cette règle en créant des tableaux de type Object qui est très large.</p>

        <pre><code class="language-java">Object[] tab = {"hello", 13, 's'};</code></pre>

        <p>Lors de la déclaration d'un tableau, doit être également précisé le nombre d'éléments qu'il contient. Le typage d'un élément et la taille du tableau ne pourront plus être modifiés ultérieurement.</p>

        <pre><code class="language-java">int[] tab = {12, 1, 34, 21};</code></pre>

        <p>Lors de la déclaration d'un tableau vide, tous les éléments sont initialisés automatiquement, les nombres à 0, les booleans à false, les objets et chaînes de caractères à null.</p>

        <pre><code class="language-java">int[] tab = new int[6];</code></pre>

        <h4>Affichage d'un tableau</h4>

        <pre><code class="language-java">for(int i=0; i&lt tab.length; i++){
    System.out.print(tab[i]+"\t");</code></pre>
        <p>ou encore</p>

        <pre><code class="language-java">for(String valeur : tab){
    System.out.print(valeur+"\t");</code></pre>


    </div>



    <!------------- LES COLLECTIONS ----------------------------->

    <h3>Les collections</h3>



        <pre><code class="language-java">import java.util.*;</code></pre>

    <p>Les collections (ensemble, liste, dictionnaires) sont des conteneurs dynamiques pouvant accepter des objets de types différents et dont la taille varie.</p>

    <p>les ensembles contiennent des éléments non indexés et sans relation d'ordre. On ne peut donc pas y accéder en faisant référence à un String ou un index. Toutefois, on peut parcourir tout l'ensemble et vérifier si un terme appartient à cet ensemble. On les utilise essentiellement pour afficher les éléments d'un dictionnaire après avoir créé un ensemble de clés.</p>

    <p>Les listes contiennent des index auxquels sont associés une valeur unique. Elles s'apparentent à des tableaux sauf que leur taille peut varier et qu'elles peuvent contenir des éléments de types différents.</p>

    <p>Les dictionnaire contiennent des clés auxquelles sont associées une valeur unique.</p>

    <h4>Les listes</h4>

    <table>
        <tr><th>Objectif</th><th>Code</th></tr>
        <tr><td>définir une liste</td><td><pre>ArrayList maListe = new ArrayList();</pre></td></tr>
        <tr><td>définir une liste à partir d'un tableau</td><td><pre>String[] tableau = new String("toto", "tata");
ArraList maListe = new ArrayList(Arrays.asList(tableau));</pre></td></tr>
        <tr><td>définir une liste composée d'un seul type d'élément</td><td><pre>ArrayList&ltString&gt maListe = new ArrayList&ltString&gt();</pre></td></tr>
        <tr><td>ajouter l'élément <em>bonjour</em></td><td><pre>maListe.add("bonjour")</pre></td></tr>
        <tr><td>ajouter l'élément <em>bonjour</em> à l'emplacement d'indice 4</td><td><pre>maListe.add(4, "bonjour")</pre></td></tr>
        <tr><td>remplace l'élément d'indice 4 par <em>bonjour</em></td><td><pre>maListe.set(4, "bonjour")</pre></td></tr>
        <tr><td>renvoyer l'élément d'indice 4</td><td><pre>maListe.get(4)</pre></td></tr>
        <tr><td>renvoyer la taille de maListe</td><td><pre>maListe.size()</pre></td></tr>
        <tr><td>renvoyer l'indice de l'élément <em>bonjour</em></td><td><pre>maListe.indexOf("bonjour")</pre></td></tr>
        <tr><td>supprimer l'élément d'indice 4</td><td><pre>maListe.remove(4)</pre></td></tr>
        <tr><td>comparer l'élément d'indice 4 à celui d'indice 5</td><td><pre>maListe.get(4).equals(maListe.get(5)</pre></td></tr>
        <tr><td>tester si l'élément <em>bonjour</em> appartient à maListe</td><td><pre>maListe.contains("bonjour)</pre></td></tr>
        <tr><td>vider maListe</td><td><pre>maListe.clear()</pre></td></tr>
        <tr><td>copier par valeurs de maListe</td><td><pre>ArrayList listeCopie = (ArrayList) maListe.clone();</pre></td></tr>
    </table>

    <p>ArrayList ne fonctionne qu’avec des types objets pour produire des objets. Ainsi on ne peut pas avoir de liste avec des éléments de type int. Pour pallier ce problème, Java a prévu de faire correspondre à chaque type primitif un objet équivalent. Ainsi au type primitif int correspond l’objet Integer, au type primitif double correspond le type complexe Double. L'autoboxing permet de passer d'un type primitif à son objet correspondant de façon automatisée. En revanche, il convient de déclarer les listes avec les types objet et non les types primitifs. On écrira ainsi :</p>
        <pre><code class="language-java">ArrayList&ltInteger&gt maListe = new ArrayList&ltInteger&gt();</code></pre>

    <p>Attention, la comparaison de 2 éléments ne se fait pas avec l'opérateur == car on compare des objets et non des types primitifs.</p>
    <p>Pour afficher une liste :</p>

        <pre><code class="language-java">Iterator iterateur = maListe.iterator();
while(iterateur.hasNext()) {
    System.out.print(iterateur.next()+"\t");
}</code></pre>

        <pre><code class="language-java">for(int i=0; i&ltmaListe.size();i++) {
    System.out.print(maListe.get(i)+"\t");
}</code></pre>

    <h4>Les dictionnaires</h4>

        <table>
            <tr><th>Objectif</th><th>Code</th></tr>
            <tr><td>définir un dictionnaire</td><td><pre>HashMap&ltString, String&gt dico = new HashMap&ltString, String&gt();</pre></td></tr>
            <tr><td>ajouter l'élément <em>lundi, Monday</em></td><td><pre>dico.put("lundi", "Monday")</pre></td></tr>
            <tr><td>remplace l'élément de clé <em>lundi</em></td><td><pre>dico.put("lundi", "Montag")</pre></td></tr>
            <tr><td>renvoyer la valeur de l'élément de clé <em>lundi</em></td><td><pre>dico.get("lundi")</pre></td></tr>
            <tr><td>renvoyer la taille de dico</td><td><pre>dico.size()</pre></td></tr>
            <tr><td>supprimer l'élément de clé <em>lundi</em></td><td><pre>dico.remove("lundi")</pre></td></tr>
            <tr><td>vider dico</td><td><pre>dico.clear()</pre></td></tr>
        </table>

        <p>Pour afficher un dictionnaire :</p>

        <pre><code class="language-java">HashMap dico = new HashMap();
Set ensemble = dico.keySet();
for(Object clef : ensemble){
    System.out.println(clef+" :"dico.get(clef));
}</code></pre>

        <pre><code class="language-java">Iterator iterateur = ensemble.iterator();
while(iterateur.hasNext()) {
Object clef = iterateur.next();
    System.out.println(clef+":"+dico.get(clef));
}</code></pre>

        <h4>Vector</h4>

        <p>La classe Vector, aujourd'hui désuète, permet de définir des listes dont la taille est fixe, i.e. les objets de classe Vector se manipulent comme des listes mais il faut définir leur taille au moment de la déclaration et ne pas dépasser cette taille. Notons que la classe Vector est compatible avec la synchronisation avec threads. </p>


    </div>



    <!-- LES DATES -------------------------------------------------->

    <h3 id="#dates">Les dates</h3>



        <h4>La classe GregorianCalendar</h4>

    <p>L'utilisation de la classe Date est obsolète. Il est préférable d'utiliser la classe GregorianCalendar qui hérite de la classe abstraite Calendar.</p>
    <p>On peut afficher le timestamp du moment sans formattage particulier en utilisant</p>
    <pre><code class="language-java">new GregorianCalendar().getTime()</code></pre>

    <p>Pour instancier une date à la date du jour, on utilise</p>
    <pre><code class="language-java">GregorianCalendar date = new GregorianCalendar();</code></pre>

    <p>Pour instancier une date à la date du 03/06/2018</p>
    <pre><code class="language-java">GregorianCalendar date = new GreogorianCalendar(2018,05,03);</code></pre>
    <p>car les mois sont notés de 0 à 11.</p>

    <p>Les différents éléments de date sont les suivants :</p>
    <pre><code class="language-java">date.get(Calendar.YEAR);
date.get(Calendar.MONTH);
date.get(Calendar.DAY_OF_MONTH);
date.get(Calendar.DAY_OF_WEEK);</code></pre>

    <p>On remarque que Calendar.YEAR concerne la classe Calendar et non l’objet date. On peut modifier la date prise en compte dans l’objet date de la façon suivante :</p>
    <pre><code class="language-java">date.set(Calendar.YEAR, annee);
date.set(Calendar.MONTH, mois);
date.set(Calendar.DAY_OF_MONTH, jour);
date.set(Calendar.DAY_OF_WEEK, jourDeLaSemaine);</code></pre>

    <fieldset><legend>ATTENTION</legend><p> Calendar.MONTH va de 0 à 11, et 0 est donc le mois de janvier. Calendar.DAY_OF_WEEK va de 1 à 7, et 1 est donc dimanche.</p></fieldset>

    <p>Toutefois, si on veut afficher correctement la date, on peut utiliser</p>
    <pre><code class="language-java">System.out.printf("%04d,%02d,%02d,%02d\n",annee,mois,jour,jourSemaine);</code></pre>

    <p>ou encore formatter de la façon suivante :</p>
    <pre><code class="language-java">SimpleDateFormat formattage = new SimpleDateFormat("yyyy-MM-dd-EEEE");
System.out.println(formattage.format(date.getTime()));</code></pre>

    <p><em>Exemple de saisie clavier de date puis affichage de la date saisie :</em></p>

    <pre><code class="language-java">Scanner saisie = new Scanner(System.in);
System.out.println("entrez année");
int annee = saisie.nextInt();
System.out.println("entrez mois");
int mois = saisie.nextInt();
System.out.println("entrez jour");
int jour = saisie.nextInt();

GregorianCalendar date = new GregorianCalendar(annee,mois,jour);
date.set(Calendar.MONTH, mois-1);
SimpleDateFormat formattage = new SimpleDateFormat("yyyy-MM-dd-EEEE");
System.out.println(formattage.format(date.getTime()));</code></pre>

        <h4>Répétition d'une instruction à l'aide d'un thread</h4>

        <p><em>La classe Timer :</em></p>
        <pre><code class="language-java">import java.util.*;</code></pre>

        <p>Pour répéter une action à intervalles réguliers, on peut utiliser l'équivalent d'un thread avec la classe Timer.</p>

        <pre><code class="language-java">public class Principale {
    public static void main(String[] args) {
        Timer timer = new Timer();
        TimerTask tache = new Action();
        timer.schedule(tache, 2000, 10); // toutes les 2000 ms, 10 répétitions
    }
}</code></pre>

        <p>et la tâche à effectuer plusieurs fois :</p>

        <pre><code class="language-java">public class Action extends TimerTask{
    public void run(){
        System.out.println("hello world");
    }
}</code></pre>

        <p><em>Directement avec la classe Thread :</em></p>
        <p>On peut également obtenir le même résultat sans la classe <em>Timer</em> en utilisant un thread.</p>

        <pre><code class="language-java">public class Principale {
    public static void main(String[] args) {
        Action t = new Action();
        t.start();
    }
}</code></pre>

        <p>et la tâche à effectuer plusieurs fois :</p>
        <pre><code class="language-java">public class TimeThread extends Thread {
    public void run(){
        for(int i=0; i<10; i++) { // 10 répétitions
            try {
                Thread.sleep(2000); // toutes les 2000 ms
                System.out.println("hello world");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>

</div>

