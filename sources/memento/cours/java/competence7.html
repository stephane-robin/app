<h2>Java</h2>


    <!-- Le RMI ------------------------------>

    <h3 id="mecanismermi">RMI Remote Method Invocation</h3>



    <p>Le mécanisme RMI permet d'appeler du code à distance, en créant un objet distant sur un serveur. Notons que l'appel à distance est bloquant. Cette technique offre pour avantages de mettre à jour le client de manière transparente et de masquer l'exécution distante du code tout en travaillant comme si l'exécution était locale.</p>

        <pre><code class="language-java">import java.rmi.*;
import java.rmi.server.*;
import java.util.*;
import java.io.*;
import java.net.*;</code></pre>

        <h4>Fonctionnement d'une communication par RMI</h4>

        <p>Le serveur implémente un objet distant qui est publié dans un serveur de noms (<em>registry</em>), i.e. qu'il est associé à un nom à partir duquel les applications clientes pourront récupérer un talon de cet objet. Pour ce faire, Java crée automatiquement sur le serveur une représentation distante appelée <em>skeleton</em> et sur le client une représentation locale appelée <em>stub</em>, qui sont transparentes pour le programmeur car elles n'apparaissent pas dans les différentes classes. Le client utilise alors ce <em>stub</em> comme si l'objet distant était local.</p>

        <img src="../../images/memento/rmi.png" alt="rmi">

        <h4>Exemple d'utilisation d'une méthode distante côté serveur :</h4>

        <p>On présente ici un exemple où le client appelle une procédure sayHello présente côté serveur pour afficher <em>Hello bob</em> côté serveur.</p>

        <pre><code class="language-java">public interface Hello extends Remote {
    public void sayHello(String nom) throws RemoteException;
}</code></pre>

    <p><em>Côté serveur :</em></p>

    <p>L'implémentation de l'interface se fait côté serveur et ne doit pas être présente côté client.</p>

    <pre><code class="language-java">public class HelloImpl extends UnicastRemoteObject implements Hello {
    public HelloImpl() throws RemoteException {
        super();
    }
    public void sayHello(String nom) throws RemoteException {
        System.out.println("Hello "+nom);
    }
}</code></pre>

    <p>Dans la classe principale côté serveur, il faut instancier l'implémentation.</p>

    <pre><code class="language-java">public class ServeurHello {
    public static void main(String[] args) {
        try {
            // creation de l'objet distant
            HelloImpl objetDistant = new HelloImpl();
            // publication de objetDistant dans le serveur de noms, ce qui crée le skeleton
            Naming.rebind("repertoirehello", objetDistant);
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client :</em></p>

    <p>L'appel côté client d'une méthode d'un objet distant consiste à obtenir une référence sur l'objet distant puis à appeler la méthode à partir de cette référence.</p>
    <pre><code class="language-java">public class ClientHello {
    public static void main(String[] args) {
        try {
            // args[0] represente l'url qui sera le 1er argument entre en ligne de commande
            // lors de l'exécution de java Client localhost:5555, donc ici localhost:5555
            // le fait de pointer vers l'adresse de l'interface Hello cree le stub
            Hello obj = (Hello) Naming.lookup("//"+args[0]+"/repertoirehello");
            obj.sayHello("bob");
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (NotBoundException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p>La gestion de sécurité se réalise à travers une instance de la classe java.rmi.RMISecurityManager, à la fois côté client et serveur :</p>
<pre><code class="language-java">if(System.getSecurityManager()==null){
    System.setSecurityManager(new RMISecurityManager());
}</code></pre>

<p>qui nécessite la bibliothèque :</p>
        <pre><code class="language-java">import java.lang.*;</code></pre>

        <p>Il faut ensuite rajouter dans le package courant le fichier <em>policy</em> suivant :</p>
        <pre><code class="language-java">grant{
    permission java.net.SocketPermission "*:1024-65535", connect,accept";
    permission java.net.SocketPermission "*:80", "connect";
}</code></pre>

        <p>ou encore pour tout permettre :</p>

        <pre><code class="language-java">grant{
    permission java.security.AllPermission;
}</code></pre>

        <h4>Exemple d'utilisation d'une méthode distante côté client :</h4>

        <p>On présente un exemple où le client appelle une procédure sayHello présente côté serveur pour afficher <em>Hello bob</em> côté client.</p>

        <pre><code class="language-java">public interface Hello extends Remote {
    public String sayHello(String nom) throws RemoteException;
}</code></pre>

        <p><em>Côté serveur :</em></p>

        <pre><code class="language-java">public class HelloImpl extends UnicastRemoteObject implements Hello {
    public HelloImpl() throws RemoteException {
        super();
    }
    public String sayHello(String nom) throws RemoteException {
        return "Hello "+nom;
    }
}</code></pre>

        <pre><code class="language-java">public class ServeurHello {
    public static void main(String[] args) {
        try {
            // creation de l'objet distant
            HelloImpl objetDistant = new HelloImpl();
            // publication de objetDistant dans le serveur de noms, ce qui crée le skeleton
            Naming.rebind("repertoirehello", objetDistant);
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p><em>Côté client :</em></p>

         <pre><code class="language-java">public class ClientHello {
    public static void main(String[] args) {
        try {
            // args[0] represente l'url qui sera le 1er argument entre en ligne de commande
            // lors de l'exécution de java Client localhost:5555, donc ici localhost:5555
            // le fait de pointer vers l'adresse de l'interface Hello cree le stub
            Hello obj = (Hello) Naming.lookup("//"+args[0]+"/repertoirehello");
            System.out.print(obj.sayHello("bob"));
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (NotBoundException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <h4>Exemple d'une boite de messagerie par RMI :</h4>

        <p>Dans cet exemple, le client peut s'inscrire à un service de messagerie, envoyer un message composé d'un identifiant, du nom d'utilisateur, la date et le contenu, consulter le dernier message d'un client par son nom d'utilisateur. Pour cela, on écrase les messages d'un utilisateur au fur et à mesure de leur envoi. Le serveur annonce à tous les clients lorsqu'un utilisateur s'inscrit.</p>

<p><em>L'interface :</em></p>

<pre><code class="language-java">public interface Boite extends Remote{
    public void inscrire(String user, Notification) throws RemoteException;
    public void envoyerMessage(Message message) throws RemoteException;
    public Message getMessage(int id) throws RemoteException;
}</code></pre>

    <p><em>Côté serveur :</em></p>

        <p>l'implémentation :</p>
<pre><code class="language-java">public class BoiteImpl extends UnicastRemoteObject implements Boite{
    HashMap&ltInteger,Contact&gt tableContact = new HashMap&ltInteger,Contact&gt();
    int nbContact;
    HashMap&ltInteger, Message&gt tableMessage = new HashMap&ltInteger, Message&gt();

    public BoiteImpl() throws RemoteException{
        super();
        nbContact = 0;
    }

    @Override
    public void inscrire(String nom, Notification obj) throws RemoteException{
        nbContact += 1;
        Contact c = new Contact(nbContact, nom, obj);
        tableContact.put(nbContact, c);

        Set ensemble = tableContact.keySet();
        for(Object clef : ensemble){
            tableContact.get(clef).obj.informerInscription(c.nom);
    }

    public void envoyerMessage(int idClient, Message message) throws RemoteException{
        tableMessage.put(idClient, message);
    }

    public Message getMessage(int idClient) throws RemoteException {
        return tableMessage.get(idClient);
    }
}</code></pre>

    <p>et la classe principale :</p>
<pre><code class="language-java">public class ServeurBoite {
    public static void main(String[] args){
        try{
            BoiteImpl objDistant = new BoiteImpl();
            Naming.rebind("DossierBoite", objDistant);
        }catch(RemoteException e){
            e.printStackTrace();
        }catch(MalformedURLException e){
            e.printStackTrace();
        }
    }
}</code></pre>

    <p><em>Côté client :</em></p>

<pre><code class="language-java">public class Client {
    public static void main(String[] args){
        try{
            Boite obj = (Boite)Naming.lookup("//"+args[0]+"/DossierBoite");
            obj.inscrire("bob", new NotificationImpl());
            Message mess = new Message(113, "Mike", new Date(), "hello");
            obj.envoyerMessage(mess);
            System.out.println("message : "+obj.getMessage(113).toString());
        }catch(RemoteException e){
            e.printStackTrace();
        }catch(NotBoundException e){
            e.printStackTrace();
        }catch(MalformedURLException e){
            e.printStackTrace();
        }
    }
}</code></pre>

        <p>L'interface côté client pour que le serveur envoie un message à tous les clients leur indiquant la connexion d'un client :</p>

        <pre><code class="language-java">public interface Notification extends Remote{
    public void informerInscription(String nom) throws RemoteException;
}</code></pre>

        <p>l'implémentation côté client :</p>

        <pre><code class="language-java">public class NotificationImpl extends UnicastRemoteObject implements Notification{
    public NotificationImpl() throws RemoteException{
        super();
    }

    @Override
    public void informerInscription(String nom) throws RemoteException{
        System.out.println(nom+" vient de se connecter");
    }
}</code></pre>

        <p>Si les objets distants attendent la connexion en permanence, les ressources mémoire sont monopolisées inutilement. Pour cette raison, on préfère créer des objets distants activables. L'utilisation de la classe UnicastRemoteObject est réservée au développement d'objets distants temporaires.</p>
        <p>Notons que l'application cliente devra également gérer la synchronisation des appels à distance à l'aide de threads pour éviter le blocage du système.</p>

        <p>La gestion de sécurité est modifiée pour pouvoir créer le groupe d'activation :</p>

        <pre><code class="language-java">grant{
    permission java.net.SocketPermission "machine:*", accept, resolve";
}</code></pre>

        <p><em>côté serveur et côté client :</em></p>

        <p>La classe Message :</p>
        <pre><code class="language-java">public class Message implements Serializable{
    int id;
    String nom;
    Date date;
    String contenu;

    public Message(int id, String nom, Date date, String contenu) {
        this.id = id;
        this.nom = nom;
        this.date = date;
        this.contenu = contenu;
    }

    @Override
    public String toString(){
        return "Le "+date+" "+nom+" a écrit : "+contenu;
    }
}</code></pre>

        <pre><code class="language-java">public class Contact{
    int id;
    String nom;
    Notification obj;

    public Contact(int id, String nom, Notification obj){
        this.id = id;
        this.nom = nom;
        this.obj = obj;
    }
}</code></pre>

        <fieldset><legend>ATTENTION</legend><p>Lors d'un appel distant les paramètres, les valeurs de retour et les exceptions sont transmis par copie et doivent donc être sérialisables. Or les types primitifs et les objets distants le sont par défaut. En revanche, les types créés ne sont pas sérialisables mais peuvent le devenir si les classes correspondantes implémentent l'interface Serializable.</p></fieldset>

<h4>Activation d'objets distants</h4>

        <p>L’activation permet d’éviter l’exposition permanente des objets distants de la classe UnicastRemoteObject. L’objectif est de créer automatiquement des objets RMI à la demande. Ce mécanisme nécessite une référence permanente.</p>

        <h4>Exemple d'activation e transmission d'une chaîne de caractères par RMI :</h4>

        <pre><code class="language-java">import java.rmi.*;
import java rmi.activation.*;
import java.util.*;</code></pre>

        <p>On présente ici une procédure où le client affiche <em>Hello Mike</em> en utilisant la procédure <em>sayHello</em> présente sur le serveur.</p>

        <p><em>Côté serveur :</em></p>

        <pre><code class="language-java">public interface Hello extends Remote {
    public void sayHello(String nom) throws RemoteException;
}</code></pre>

        <p>L'implémentation de l'interface se fait côté serveur et ne doit pas être présente côté client.</p>

        <pre><code class="language-java">public class HelloImpl extends Activatable implements Hello {
    public HelloImpl(ActivationID id, MarshalledObject data) throws RemoteException {
        super(id, 0);
    }
    public void sayHello(String nom) throws RemoteException {
        System.out.println("hello "+nom);
    }
}</code></pre>

        <p>Dans la classe principale côté serveur, il faut instancier l'implémentation.</p>

        <pre><code class="language-java">public class ServeurHello {
    public static void main(String[] args) {
        try { // creation de l'objet distant activable
            System.setSecurityManager(new RMISecurityManager();
            Properties prop = new Properties();
            prop.put("java.security.policy", "java.policy");
            ActivationGroupDesc agd = new ActivationGroupDesc(prop, null);
            ActivationGroupID agi = ActivationGroup.getSystem().registerGroup(agd);
            //MarshalledObject data = new MarshalledObject(new Donnees(" Boite Vio ", 2 0));
            ActivationDesc ad = new ActivationDesc(agi, "DossierHello.HelloImpl", arg[0], null);
            Hello objetDistant = (Hello) Activatable.register(ad);

            Naming.rebind("DossierHello", objetDistant);
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>

        <p>Il faut toutefois modifier la politique de sécurité afin de pouvoir créer le groupe d'activation. Le fichier de politique de sécurité est le suivante :</p>

        <pre><code class="language-java">grant {
    // nécessaire pour créer le groupe d'activation
    permission java.net.SocketPermission "localhost:*","accept,resolve";
};</code></pre>

        <p><em>Côté client :</em></p>

        <p>L'appel côté client d'une méthode d'un objet distant consiste à obtenir une référence sur l'objet distant puis à appeler la méthode à partir de cette référence.</p>
        <pre><code class="language-java">public class ClientHello {
    public static void main(String[] args) {
        try {
            // args[0] represente l'url qui sera le 1er argument entre en ligne de commande
            // lors de l'exécution de java Client localhost:5555, donc ici localhost:5555
            // le fait de pointer vers l'adresse de l'interface Hello cree le stub
            Hello obj = (Hello) Naming.lookup("//"+args[0]+"/DossierHello");
            obj.sayHello("Mike");
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (NotBoundException e) {
            e.printStackTrace();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
    }
}</code></pre>


    </div>



    <!-- JMS --------------------------------------->

    <h3 id="jms">JMS Java Message Service</h3>



        <div class="pcle"><strong>message</strong> : ensemble de données groupées pour être envoyées et reçues en même temps.</br>
            <strong>serveur d'application :</strong> infrastructure offrant un contexte d'exécution pour des composants applicatifs.</br>
    <strong>JNDI Java Naming and Directory Interface</strong> : il s'agit d'une API Java de connexion à des annuaires, permettant d'accéder à différents services, d'organiser et de rechercher des informations par nommage. JNDI fait partie de Java EE, il est trés utilisé dans les serveurs d'application et nécessite le package naming</div>

    <p>JMS est une API spécialisée dans le service de messagerie (création, envoi et lecture de messages) d'une application à une autre sur un poste distant. JMS utilise un MOM Message Oriented Middleware de type JMSConnectionFactory géré par un fournisseur tels que Apache ActiveMQ qui joue le rôle de plateforme de messagerie. Les particularités de JMS sont les suivantes :</p>
        <ul>
            <li>la communication est asynchrone, un message arrivera au client sans qu'il n'ait fait de requête</li>
            <li>JMS est fiable, car il s'assure que le message est bien délivré</li>
        </ul>

        <pre><code class="language-java">import java.util.*;
import javax.naming.*;
import javax.jms.*;</code></pre>

        <h4>Fonctionnement de JMS</h4>

        <p>Les messages sont envoyés sur un objet intermédiaire MOM qui utilise une structure de file d'attente (queue) ou de sujet (topic), et le récepteur doit venir les chercher. Des bus gèrent les transports de messages vers les objets intermédiaires. De ce fait, il n'y a pas de connexion entre un émetteur et un récepteur. Les récepteurs actifs peuvent voir tous les messages délivrés par l'émetteur, mais celui-ci ne connaît pas  l'état des récepteurs actifs. Les récepteurs peuvent s'inscrire comme DurableSubscriber avec JMS2.0 et dans ce cas, les messages qu'ils n'ont pas consultés durant leur absence peuvent être lus au moment où ils se reconnectent.</p>

        <img src="../../images/memento/jms.png" alt="jms">

        <p>Ce mode de communication indirect permet de mettre en place des services avancés :</p>
    <ul>
        <li>communication de groupe (multicast)</li>
        <li>envoi et réception groupés</li>
        <li>retransmission des messages en cas de non réception</li>
        <li>trace des échanges (log)</li>
        <li>gestion des droits d'accès</li>
    </ul>

        <h4>Queue et Topic</h4>

        <p>JMS repose sur deux modes de communication principaux, la communication point-à-point et la communication événementielle.</p>
        <p> Dans la communication point-à-point, l'objet intermédiaire utilise une file d'attente (queue). Plusieurs émetteurs peuvent envoyer sur la même file d'attente mais un seul récepteur peut voir le message. On parle de communication N à 1. C'est le cas par exemple lorsqu'on utilise une imprimante. Attention, cela ne veut pas dire que seul un unique récepteur peut consulter le message, mais plutôt qu'un seul récepteur peut le consulter. Ainsi, si deux programmes se mettent en attente sur une même queue, le premier programme reçoit le premier message émis, le second progamme reçoit le second message. La structure queue peut également être utilisée vers un destinataire unique pour éviter que tous les récepteurs ayant souscrit à un topic aient la possibilité de consulter un message. C'est le cas par exemple d'une réponse vers un unique utilisateur lorsqu'on se trouve en mode topic. Il faut dans ce cas que l'émetteur initial dispose d'une queue, qu'il annonce dans son message initial en vue d'une réponse.</p>
        <p> Dans la communication événementielle, l'objet intermédiaire utilise un sujet (topic). L'émetteur publie son message sur un topic. Les récepteurs s'inscrivent au topic pour recevoir les messages publiés sur ce topic. Plusieurs publishers peuvent envoyer des messages sur le même topic et plusieurs subscribers peuvent consulter les messages du topic. C'est le cas par exemple lors d'un fil de discussion dans un <em>chat</em>. Notons que si deux programmes se mettent en attente sur un même topic, les deux programmes reçoivent le message contrairement à une structure queue.</p>

    <h4>Exemple d'une communication Topic avec JMS 1.1 :</h4>

        <p>Dans cet exemple l'émetteur publie une chaîne de caractères sur l'objet intermédiaire utilisant la structure topic. Un récepteur souscrit au topic pour lire la chaîne de caractères.</p>

        <p><em>Côté émetteur :</em></p>

<pre><code class="language-java">public class Publisher {
    public static void main(String[] args) {
		try {
			// Le detail des proprietes (url, port, ...) se trouve dans jndi.properties.
            // La creation de prop n'est nécessaire que côté serveur
	    	Properties prop = new Properties();
            // creation du contexte
            InitialContext ctx = new InitialContext();
            // creation et acces au topic
            Topic topic = (Topic) ctx.lookup("MyTopic");
            // connexion au provider, creation de l'objet intermediaire
            TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactory");
            // connexion au bus permettant le transport vers le MOM
            TopicConnection conn = factory.createTopicConnection();
            conn.start();
            // creation de session
            // false pour spécifier que les messages reçus seront traités en accord
            // avec le second paramètre Session.AUTO_ACKNOWLEDGE
            TopicSession sess = conn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

		    // creation d'un objet emetteur
	   		TopicPublisher pbr = sess.createPublisher(topic);
	    	pbr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

			// publication d'un message "hello world"
	    	TextMessage tmess = sess.createTextMessage("hello world");
	    	// possibilité de changer ultérieurement avec message.setText("hello world");
	    	pbr.publish(tmess);

	    	// fermeture de connexion
	    	conn.close();
		} catch (Exception e) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <p><em>Côté récepteur :</em></p>

<pre><code class="language-java">public class Subscriber {

    public static void main(String[] args) {
		try {
            InitialContext ctx = new InitialContext();
            Topic topic = (Topic) ctx.lookup("MyTopic");
            TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactory");
            TopicConnection conn = factory.createTopicConnection();
            conn.start();
            TopicSession sess = conn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

	    	// creation d'un objet destinataire
	    	TopicSubscriber scr = sess.createSubscriber(topic);

		    // lecture d'un message, receive est une fonction bloquante
	    	TextMessage tmess = (TextMessage) scr.receive();
	    	System.out.println("message lu : " + tmess.getText());

		    conn.close();
		} catch( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

        <p>La méthode receive() est bloquante. On peut rendre durable le récepteur en remplaçant sess.createSubscriber(topic) par sess.createDurableSubscriber(topic, nom_id). Il faudra ensuite terminer cette fonctionnalité avec sess.unsubscribe(nom_id)</p>

    <h4>Exemple d'une communication Queue avec JMS 1.1 :</h4>

      <p>Dans cet exemple un émetteur envoie un objet de type Message à l'objet intermédiaire utilisant la structure queue. Un récepteur consulte la chaîne de caractères.</p>

        <p><em>Côté émetteur</em></p>

        <pre><code class="language-java">public class Emetteur {

    public static void main(String[] args) {
		try {
	    	InitialContext ctx = new InitialContext();
            // creation et acces a la file d'attente
            Queue queue = (Queue) ctx.lookup("MyQueue");
            QueueConnectionFactory factory = (QueueConnectionFactory) ctx.lookup("MyConnectionFactory");
            QueueConnection conn = factory.createQueueConnection();
            conn.start();
            QueueSession sess = conn.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

	    	QueueSender sdr = sess.createSender(queue);
	    	sdr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

	    	Message mess = new Message("bob", new Date(), "hello world");
            ObjectMessage obj = sess.createObjectMessage(mess);
	   		sdr.send(obj);

	   		conn.close();
		} catch( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

        <p><em>Côté récepteur :</em></p>

        <pre><code class="language-java">public class Receiver {

    public static void main(String[] args) {
		try {
            Properties prop = new Properties();
	    	InitialContext ctx = new InitialContext();
            Queue queue = (Queue) ctx.lookup("MyQueue");
            QueueConnectionFactory factory = (QueueConnectionFactory) ctx.lookup("MyConnectionFactory");
            QueueConnection conn = factory.createQueueConnection();
            conn.start();
            QueueSession sess = conn.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

	    	QueueReceiver rcv = sess.createReceiver(queue);

	    	ObjectMessage obj = (ObjectMessage) rcv.receive();
            Message mess = (Message) obj.getObject();
		    System.out.println("message reçu: " + mess.toString());

	    	conn.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
    }
}</code></pre>

        <p>La classe Message doit être présente à la fois côté serveur et côté client. Comme l'objet doit être transmis, la classe Message implémente l'interface Serializable.</p>

        <pre><code class="language-java">public class Message implements Serializable{
    String nom;
    Date date;
    String contenu;

    public Message(String nom, Date date, String contenu){
        this.nom = nom;
        this.date = date;
        this.contenu = contenu;
    }

    @Override
    public String toString(){
        System.out,print("nom: "+nom+",date: "+date+", contenu: "+contenu);
    }
}</code></pre>

    <h4>Exemple d'un échange sur un Topic avec JMS 1.1 :</h4>

        <p>Dans cet exemple, un serveur publie sur l'objet intermédiaire une chaîne de caractères et consulte une chaîne de caractères publiée en réponse par un client. L'échange se fait au sein d'une unique session.</p>

    <p><em>Côté serveur</em></p>

    <pre><code class="language-java">public class Serveur {
	public static void main(String[] args) {
		try {
            Properties prop = new Properties();
	    	InitialContext ctx = new InitialContext();
            Topic topic = (Topic) ctx.lookup("MyTopic");
            TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactory");
            TopicConnection conn = factory.createTopicConnection();
            conn.start();
            TopicSession sess = conn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

            // envoi d'un message
	    	TopicPublisher pbr = sess.createPublisher(topic);
	    	pbr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
            TextMessage tmess = sess.createTextMessage("hello");
	    	pbr.publish(tmess);

	    	// attente que le destinataire reçoive le message
	    	Thread.sleep( 5000 );

	    	// reception d'un message reponse
            TopicSubscriber sbr = sess.createSubscriber(topic);
	    	TextMessage treponse = (TextMessage) sbr.receive();
	    	System.out.println(treponse.getText());

	    	conn.close();
		} catch ( Exception e ) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

    <p><em>Côté client</em></p>

    <pre><code class="language-java">public class Client {

    public static void main(String[] args) {
		try {
	    	InitialContext ctx = new InitialContext();
            Topic topic = (Topic) ctx.lookup("MyTopic");
            TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactory");
            TopicConnection conn = factory.createTopicConnection();
            conn.start();
            TopicSession sess = conn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

	    	// lecture d'un message
	    	TopicSubscriber sbr = sess.createSubscriber(topic);
            TextMessage tmess = (TextMessage) sbr.receive();
	    	System.out.print(tmess.getText());

	    	// envoi d'un message reponse
            TopicPublisher pbr = sess.createPublisher(topic);
	    	pbr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
	    	TextMessage treponse = sess.createTextMessage("world");
	    	pbr.send(treponse);

	    	conn.close();
		} catch (Exception e) {
	    	e.printStackTrace();
		}
    }
}</code></pre>

        <h4>Exemple de communication topic avec réponse ciblée en JMS1.1 :</h4>

        <p>Dans cet exemple un serveur publie une chaîne de caractères sur un topic, et un client répond en envoyant une chaîne de caractères sur une queue, pour que seul le serveur puisse le consulter. Le serveur doit donc dans ce cas envoyer sur le topic un objet contenant la chaîne de caractères et la référence du queue à laquelle est connectée le serveur.</p>

        <p><em>Côté serveur :</em></p>

<pre><code class="language-java">public class Serveur{
  public static void main(Strings[] args){
    try{
      Properties prop = new Properties();
      InitialContext ctx = new InitialContext();
      Topic topic = (Topic) ctx.lookup("MyTopic");
      TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactoy");
      TopicConnection connT = factory.createTopicConnection();
      connT.start();
      TopicSession sessT = connT.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

      TopicPublisher pbr = sessT.createPublisher(topic);
      pbr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
      TextMessage tmess = sess.createTextMessage("hello");
      pbr.publish(tmess);

      Queue queue = (Queue) ctx.lookup("MyQueue"):
      QueueConnectionFactory queue = (QueueConnectionFactory) ctx.lookup("MyConnectionfactory");
      QueueConnection connQ = queue.createQueueConnection();
      connQ.start();
      QueueSession sessQ = connQ.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

      QueueReceiver rcv = sessQ.createReceiver(queue);
      TextMessage tmess = (TextMessage) rcv.receive();

      connT.close();
      connQ.close();
    }catch (Exception e){
      e.printStackTrace();
    }
  }
}</code></pre>

        <p><em>Côté client concerné par la réponse, les autres clients n'ont pas connaissance du code queue:</em></p>

        <pre><code class="language-java">public class Client{
  public static void main(String[] args){
     try{
        InitialContext ctx = new InitialContext();
        Topic topic = (Topic) ctx.lookup("MyTopic");
        TopicConnectionFactory factory = (TopicConnectionFactory) ctx.lookup("MyConnectionFactoy");
        TopicConnection connT = factory.createTopicConnection();
        connT.start();
        TopicSession sessT = connT.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);

        TopicSubscriber sbr = sess.createSubscriber(topic);
        TextMessage tmess = (TextMessage) sbr.receive();

        Queue queue = (Queue) ctx.lookup("MyQueue"):
        QueueConnectionFactory queue = (QueueConnectionFactory) ctx.lookup("MyConnectionfactory");
        QueueConnection connQ = queue.createQueueConnection();
        connQ.start();
        QueueSession sessQ = connQ.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

        QueueSender sdr = sessQ.createSender(queue);
        sdr.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
        TextMessage tmess = sessQ.createTextMessage("world");
        sdr.send(tmess);

        connT.close();
        connQ.close();
     }catch (Exception e){
      e.printStackTrace();
    }
  }
}</code></pre>

        <p>Il est possible de créer un Listener chez le serveur, qui attend un message pour suivre des instructions.</p>

        <pre><code class="language-java">AlertListener al = new AlertListener();
pbr.setMessageListener(al);</code></pre>

        <pre><code class="language-java">public class AlertListener implements MessageListener{
    public void onMessage(Message mess){
        try{
            System.out.print("Alerte:"+(TextMessage)mess.getText());
        catch(JMSException e){
            e.printStackTrace();
        }
    }
}</code></pre>

    </div>



    <!-- Les services Web -------------------------------------------------->

    <h3 id="servicesweb">Le service Web REST</h3>



    <div class="pcle"><strong>sérialisation</strong> : codage d'une information sous fome de suite de données atomiques.</br>
    <strong>parser un fichier</strong> : analyser un fichier afin d'en retirer les informations utiles.</br>
        <strong>serveur d'applications</strong> : logiciel d'infrastructure offrant un contexte d'exécution pour des applications Web et non pas de simples procédures ou scripts.</br>
        <strong>verbe HTTP</strong> : méthodes HTTP GET, POST, PUT, DELETE, ...</br>
        <strong>POJO Plain Old Java Object </strong> : objet Java lié à aucune restriction autre que celles de la spécification du langage Java. Un POJO n'étend pas de classe pré-définie, n'implémente pas d'interface et ne contient pas d'annotation pré-spécifiée @...</br>
        <strong>Servlet </strong> : classe Java qui permet de créer dynamiquement des données au sein d'un serveur HTTP. Ces données sont présentées au format HTML ou XML.</div>

    <p>Les services Web sont un ensemble de technologies permettant l'invocation de méthodes distantes. La communication et l'échange de données sont basés sur les standards Web HTTP et XML. SOAP et REST sont 2 solutions permettant à un client d'accéder aux services Web.</p>

    <p>Les principaux avantages des services Web sont les suivants :</p>
    <ul>
        <li>portabilité entre différents langages, différents systèmes d'exploitation</li>
        <li>utilisation de standards et protocoles ouverts</li>
        <li>utilisation des formats XML dans les échanges de données</li>
        <li>flexibilité, extensibilité</li>
    </ul>

    <h4>SOAP Simple Object Access Protocol</h4>

    <p>SOAP est un protocole de RPC Remote Procedure Call orienté objet et basé sur l'échange de données structurées en XML. SOAP permet l'appel de méthodes distantes dans un environnement distribué.</p>
    <p>Un message SOAP est un document XML composé d'une <em>envelope</em> avec un <em>header</em> et le <em>body</em>, corps du message. Dans le cas de l'envoi d'une image, on peut utiliser un message SOAP avec attachement en utilisant un message MIME Multimedia Internet Mail Extension.</p>

    <p>L'architecture des services SOAP se base sur les protocoles suivants :</p>
    <ul>
        <li>un protocole de transfert HTTP ou SMTP, les données échangées sont représentées en XML</li>
        <li>un protocole de description des services et méthodes WSDL</li>
        <li>un protocole de localisation des services UDDI, facultatif</li>
    </ul>

    <p>WSDL Web Service Description Langage donne la description au format XML des services Web en précisant les méthodes pouvant être invoquées. Le client a besoin de cette description détaillée des services Web avant de pouvoir les utiliser.</p>

    <p>UDDI Universal Description Discovery and Integration est un annuaire des services publiés par les providers. Une entrée du répertoire UDDI est constituée d'un fichier XML.</p>

    <p><em>Exemple de requête SOAP :</em></p>

    <pre><code class="language-java">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

&lt?xml version="1.0" encoding="utf-8"?&gt
&ltsoap:Envelope xmlns:soap="http://www.w3.org/2001/soap/envelope"&gt
&ltsoap:Body&gt
    &ltm:GetPrice xmlns:m="http://www.w3schools.com/prices"&gt
        &ltm:Item&gtApples&lt/m:Item&gt
    &lt/m:GetPrice&gt
&lt/soap:Body&gt
&lt/soap:Envelope&gt</code></pre>

    <p><em>Réponse SOAP :</em></p>

    <pre><code class="language-java">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

&lt?xml version="1.0" encoding="utf-8"?&gt
&ltsoap:Envelope xmlns:soap="http://www.w3.org/2001/soap/envelope"&gt
&ltsoap:Body&gt
    &ltm:GetPriceResponse xmlns:m="http://www.w3schools.com/prices"&gt
        &ltm:Price&gt2.59&lt/m:Price&gt
    &lt/m:GetPriceResponse&gt
&lt/soap:Body&gt
&lt/soap:Envelope&gt</code></pre>

    <h4>Développement d'un service Web SOAP avec JAX-WS</h4>

    <p>JAX-WS est intégré dans Java pour développer des services Web.</p>
    <p>Le développement d'un service Web SOAP avec JAX-WS se fait en plusieurs étapes :</p>
    <ul>
        <li>créer une interface publique</li>
        <li>implémenter l'interface</li>
        <li>publier et déployer l'application localement</li>
    </ul>

        <p>Les fichiers côté client sont créés lors de la génération du stub</p>
        <p> le fichier main du client : voir cours</p>
    <pre><code class="language-java">// interface publique
import javax.jws.*;
import javax.jws.soap.*;

@WebService
@SOAPBinding(style = Style.RCP)
public interface HelloWorld {
    String getHelloWorldAsString(String nom);
}</code></pre>

    <pre><code class="language-java">// implémentation de l'interface
        // voici mon contrat WSDL
import javax.jws.*;

@WebService(endpointInterface = "ws.HelloWorld")
public class HelloWorldImpl implements HelloWorld {

    @Overrride
    public String getHelloWorldAsString(String nom) {
        return "Hello World JAX-WS "+nom;
    }
}</code></pre>

<pre><code class="language-java">// publication de l'application et déploiement
    // j'ai exécuté la requête et je retourne le résultat
import javax.xml.ws.*;

public class HelleWorldPublisher {
    public static void main(String[] args) {
        Endpoint.publish("http://localhost:9999/ws/hello", new HelloWorldIml());
    }
}</code></pre>

    <h4>REST REpresentational State Transfer</h4>

    <p>REST utilise le protocole HTTP pour transférer les données qui sont identifiées par des URI Uniform Resource Identifier. Les requêtes du protocole HTTP sont composées d'une ligne de commande, d'une entête et d'un corps de message. Le format de stockage des données est principalement JSON JavaScript Object Notation, mais également XML.</p>

        <p>Les URI regroupent 2 sous-types d'identificateurs, les URN Uniform Resource Name et les URL Uniform Resource Locator. Les URL comprennent les chemins d'accès aux ressources accessibles. Par exemple http://domaine/chemin et mailto: adresseMail@gmail.com sont des URL. Les URN permettent de définir une identification unique et persistance pour une ressource. Par exemple l'adresse MAC d'une ordinateur, la référence ISBN:0-233-988897-2 d'un livre sont des URN.</p>

    <p>Les principales caractéristiques des services REST sont les suivantes :</p>
    <ul>
        <li>identification des données via des URI</li>
        <li>manipulation des données avec uniquement 4 opérations CRUD : Create avec la méthode @POST, Read avec la méthode @GET, Update avec la méthode @PUT et Delete avec la méthode @DELETE</li>
    </ul>

    <p>Plusieurs frameworks aident au développement des Web services REST en prenant en charge l'analyse et le traitement des requêtes côté serveur et des réponses côté client, comme par exemple Spring ou Jersey qui est intégré dans Java EE. L'interface Java pour implémenter des services Web REST s'appelle JAX-RS. Il s'agit d'un Servlet basé sur des POJO et contenant des annotations @Path, @GET, @Produces qui complètent l'objet pour en faire un objet invocable à distance à travers une méthode HTTP et accessible par un URI. L'annotation @Path permet d'indiquer que l'objet doit être exposé comme un service répondant à des requêtes REST.</p>

    <p>Les services Web REST sont généralement déployés dans les serveurs d'application comme Tomcat et JBoss.</p>

        <p>Le service Web de type REST est plus souple que le type SOAP qui est maintenant désué. REST est une API dans lequel on ne trouve pas de contrat comme pour RMI ou SOAP.</p>

        <p><em>Exemple de format JSON :</em></p>

<pre><code class="language-JSON">{
    'prenom': 'Stephane',
    'nom': 'Dupret',
    'age': 35,
    'adresse': {
        'rue': '12 bd de la libération',
        'ville': 'Marseille',
        'codePostal': '13013'
    },
    'numerosTph': [
        {
        'type': 'domicile',
        'nmr': '01234567889'
        },
        {
        'type': 'bureau',
        'nmr': '0198765432'
        }
    ]
}</code></pre>

    <p>Exemple d'utilisation de JSON avec le package Gson</p>

    <pre><code class="language-java">import com.google.gson.Gson
Gson gson = new Gson();
MyInData mid = new MyInData(45, 0.1, "hello");
String toJsonString = gson.toJson(mid);

MyInData fromJsonString = gson.froJson(jsonString, MyInData.class);</code></pre>

<h4>Exemple de communication avec un service REST :</h4>

        <p>Dans l'exemple ci-dessous, un serveur gère un service de contacts. REST ne nécessite pas de programmation côté client mais fonctionne avec un navigateur, dans lequel il convient de fournir les adresses correctes pour satisfaire les différentes requêtes. Le code au niveau du Servlet JAX-RS est le suivant :</p>

        <img src="../../images/memento/rest.png" alt="Rest">

<pre><code class="language-java">import javax.xml.bind.annotation.*;

@XmlRootElement  // les objets de type Contact doivent etre serialises en XML
public class Contact {
    int id;
    String nom;
    String email;

    public Contact(int id, String nom, String email) {
        this.id = id;
        this.nom = nom;
        this.email = email;
    }

    @Override
    public String toString() {
        return "id :" + id + ", name : " + name + ", email : " + email;
    }
}</code></pre>

        <p><em>La classe ContactBookResource</em> permet de gérer les requêtes avec la liste des contacts.</p>

<pre><code class="language-java">import java.util.*;
import javax.ws.rs.*;
import javax.ws.rs.core.*;
import javax.ws.rs.core.Response.*;

@Path("/DossierContact") // donné comme référence dans l'uri, ne correspond pas forcément au nom du dossier courant
public class ContactBookResource {
    ContactDAO dao = new ContactDAO();

    @GET
    // produit des fichiers JSON dans le cas général d'une requête, peut également produire du XML
    @Produces(MediaType.APPLICATION_JSON) // {  , MediaType.APPLICATION_XML})
    public Response  getListeContact() {
        return Response.status(Response.Status.OK).entity(dao.getListeContact()).build();
    }

    @GET
    // Dans le cas particulier d'une requete avec id, on obtient les informations du contact a partir de son id
    @Path("{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getContact(@PathParam("id") int id) {
        Contact c = dao.getContact(id);
        if (c == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        } else {
            return Response.status(Response.Status.OK).entity(c).build();
        }
    }

    @POST
    // on ajoute un contact sous forme JSON
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response setContact(Contact c) {
        Contact originalContact = dao.getContact(c.id);
        if (originalContact != null) {
            return Response.status(Response.Status.CONFLICT).build();
        } else {
            dao.setContact(c);
            return Response.status(Response.Status.OK).entity(c).build();
        }
    }

    @PUT
    // le contact est modifie a partir de son id
    @Path("{id}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response updateContact(@PathParam("id") int ident, Contact c) {
        Contact originalContact = dao.getContact(c.ident);
        if (originalContact == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        } else {
            c.id = ident;
            dao.updateContact(ident, c);
            return Response.status(Status.OK).entity(c).build();
        }
    }

    @DELETE
    // le contact est efface par rapport a son id
    @Path("{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response deleteContact(@PathParam("id") int id) {
        Contact originalContact = dao.getContact(id);
        if (originalContact == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        } else {
            dao.deleteContact(id);
            return Response.status(Status.OK).entity(originalContact).build();
        }
    }
}</code></pre>

        <p>Pour des raisons de commodité la liste des contacts est structurées en dictionnaire. Une structure de type liste n'aurait pas permis de conserver l'identité d'un contact à la suite de changements. En effet, suite à des changements, les éléments d'une liste sont bougés et leur index varie. Ce n'est pas le cas pour un dictionnaire auquel on rajoute un champ index. La classe ContactDAO permet de gérer cette liste de contacts.</p>

<pre><code class="language-java">import java.util.*;

public class ContactDAO { // DAO pour Data Access Object
    public HashMap&ltInteger, Contact&gt tableContact = new HashMap&ltInteger, Contact&gt();

    public ContactDAO() {
        Contact c1 = new Contact(0, "user1", "user1@domaine.org");
        Contact c2 = new Contact(1, "user2", "user2@domaine.org");

        tableContact.clear();
        tableContact.put(c1.id, c1);
        tableContact.put(c2.id, c2);
    }

    public ArrayList&ltContact&gt getListeContact() {
        return new ArrayList&ltContact&gt(tableContact.values());
    }

    public Contact getContact(int id) {
        return tableContact.get(id);
    }

    public void setContact(Contact c) {
        tableContact.put(c.id, c);
    }

    public void updateContact(int id, Contact c) {
        tableContact.put(id, c);
    }

    public void deleteContact(int id) {
        tableContact.remove(id);
    }
}</code></pre>

        <p>La configuration du serveur se fait grâce à la classe <em>ServletHolder</em>. La classe <em>ServletContextHandler</em> permet la gestion des principales fonctionnalités.</p>

<pre><code class="language-java">import java.util.logging.*;
import org.eclipse.jetty.server.*;
import org.eclipse.jetty.servlet.*;
import org.glassfish.jersey.servlet.*;

public class JettyServer {
    public static void main(String[] args) {
        Server srv = new Server(8080);

        // gestionnaire d'événements sur le serveur et des principales fonctionnalités
        ServletContextHandler ctx = new ServletContextHandler(ServletContextHandler.NO_SESSIONS);
        ctx.setContextPath("/"); // racine du serveur
        srv.setHandler(ctx);

        // configuration du serveur
        ServletHolder hld = ctx.addServlet(ServletContainer.class, "/rest/*");
        hld.setInitOrder(1);
        // chemin pour import de packages
        hld.setInitParameter("jersey.config.srv.provider.packages", "fr.rest");

        try {
            srv.start();
            System.out.println("Services deployed on URL = http://localhost:8080/rest/mescontacts");
            srv.join(); // gestion de threads sur Jetty
        } catch (Exception ex) {
            e.getStackTrace();
        } finally {
            srv.destroy();
        }
    }
}</code></pre>

        <p>Pour consulter les données sur le serveur, les URI pour interrogation des services sont les suivantes. On tient compte uniquement du format JSON, les instructions sont données au terminal côté client :</p>
        <ul>
            <li>pour consulter la table des contacts : </br>
                curl -H "Accept: application/json" -H "Content-Type: application/json" -X GET http://&ltserver&gt/rest/dossiercontact</li>
            <li>pour consulter le contact n°3 : </br>
                curl -H "Accept: application/json" -H "Content-Type: application/json" -X GET http://&ltserver&gt/rest/dossiercontact/3</li>
            <li>pour rajouter le contact composé de 5,tom,tom@gmail.com : </br>
                curl -H "Accept: application/json" -H "Content-Type: application/json" -X POST -d "{'id':5,'nom':'tom','email':'tom@gmail.com'}" http://&ltserver&gt/rest/dossiercontact</li>
            <li>pour mettre à jour le contact n°5 : </br>
                curl -H "Accept: application/json" -H "Content-Type: application/json" -X PUT -d "{'id':5,'nom':'tom','email':'tom12@gmail.com'}" http://&ltserver&gt/rest/dossiercontact/5</li>
            <li>pour supprimer le contact n°3 : </br>
                curl -H "Accept: application/json" -H "Content-Type: application/json" -X DELETE http://&ltserver&gt/rest/dossiercontact/3</li>
        </ul>

    <p><em>Les principaux codes statut de réponse : </em></p>
        <ul>
            <li>200 OK : tout s'est bien passé</li>
            <li>201 Created : la création de la ressource s'est bien passée</li>
            <li>204 No content : tout s'est bien passé mais le contenu de la ressource n'est pas renvoyé en réponse</li>
            <li>304 Not modified : le contenu n'a pas été modifié</li>
            <li>400 Bad request : la demande n'a pas pu être traitée correctement</li>
            <li>401 Unauthorized : l'authentification a échoué</li>
            <li>404 Not found : la ressource n'existe pas</li>
            <li>405 Method not allowed : la méthode HTTP utilisée n'est pas traitable par l'API</li>
            <li>406 Not acceptable : l'API n'est pas capable de fournir le format demandé</li>
            <li>500 Server error : le serveur a rencontré un problème</li>
        </ul>

         </div>



